---
{"dg-publish":true,"permalink":"/07-c/c-1/","dgPassFrontmatter":true}
---

# 数据结构
## 绪论
### 1.2.1 数据结构的基本概念和术语
#### 基本定义
1. 数据，是可以被计算机识别并加工处理的对象，是对客观事物的符号表示，数据不仅包括整型，实型等数值数据，还包括音频等非数值元素
2. 数据元素是由数据组成的具有一定意义的基本单位，在计算机中通常作为一个整体来处理。有些情况下，数据元素也称为元素、记录。
3. 数据项是组成数据元素的不可分割的最小单位
==数据元素是数据的最小单位,数据项是数据的最小单位==
**总结来说一个事物具有多种数据信息，则其称之为数据元素，其中的单个数据信息称之为数据项** ——例如树的节点被称为数据元素，节点中的左右子树和元素值被称为数据项
### 1.2.2数据结构
数据结构包括数据的逻辑结构和存储结构，以及数据的运算三个部分
#### 逻辑结构
##### 线性结构
1. 链表
2. 数组  
3. 队列  先进先出
4. 堆栈  后进先出，先进后出
5. 串
##### 非线性结构
1. 集合 各个元素之间没有关系
2. 图 多对多
3. 树 一对多
#### 存储结构
1. 顺序存储，就是相邻的数据元素存储到相邻的地址之中
2. 链式存储，数据元素的存储位置并不能表示它们之间的逻辑关系
3. 索引存储，有一个索引表，通过索引表来确定元素的存储位置
4. 散列存储，根据散列函数来计算出存储的位置，比如说我们常用的Mod（同余）函数
#### 常见的数据运算
1. 搜索运算
2. 插入运算
3. 删除运算
4. 更新运算，将数据结构中指定元素替换为新的元素。
### 1.3 抽象数据结构
ADT抽象数据类型名
{
数据： 数据元素及其之间关系的定义
运算：
			运算1：（参数表）：运算功能描述
			运算2：（参数表）：运算功能描述
}
抽象数据类型是一个数学模型以及在其上定义的运算集合。其最主要的两个特征是数据封装和信息隐蔽。数据封装是把数据和操纵数据的运算组合在一起的机制。信息隐蔽是指数据的使用者只需知道这些运算的定义（也称规范）便可访问数据，而无须了解数据的存储以及运算算法的实现细节。通过实行数据封装和信息隐蔽，可使数据的使用和实现相分离。==即我们只需要知道怎么用就可以了，其他的不用管==
### 1.4算法和算法分析
#### 算法的特征和评价的标准
**特征**
1. 输入 有零个或多个输入
2. 输出 至少有一个输出
3. 可行 可以完成运行,每一个步骤都可以通过基本运算来实现
4. 有限 必须能够执行有穷次结束
5. 确定 每一次运算都必须有确定的含义,不会产生二义性
**评价标准**
1. 正确性在数据输人合理的情况下，算法能够在有限的时间内达到预先规定的功能和性能要求
2. 健壮性一个好的算法在输入不合法数据时，应能做出适当处理，而不至于产生异常或是出现崩溃等严重后果。
3. 可读性∶一个好的算法应当思路清晰、简单明了。可读性高的算法便于人们阅读、理解和交流;晦涩难懂的算法容易隐藏错误，不易调试。
4. 高效性评价一个算法的效率主要包括时间和空间两方面，好的算法应具备执行效率高和占用存储空间少的特点。时间复杂度和空间复杂度是衡量算法效率的两个重要指标。
#### 算法的时间复杂度
算法时间的大小依次是O(1)<O(log2n)<O(nlog2n)<O(n^2)<O(n^3)
==算法的时间复杂度分为最好情况,最坏情况以及平均情况,我们看的最多的是平均情况==
###  算法和程序之间的关系
**联系:** 程序是计算机执行的有序集合,是算法用某种程序语言的表述,是算法在计算机上的具体实现
**区别** 程序必须用规定的程序设计语言来写,算法描述形式包括自然语言,伪代码,流程图和程序语言. 算法所描述的步骤一定是有限的,而程序是可以无限的执行的.死循环称为程序,不能称为算法.
## 线性表
### 2.1线性表的定义
线性表是零个或若干个数据元素构成的线性序列，记为（a6， a;，…，a-1）。线性表中的数据元素个数n称为线性表的长度。当 n=0时，此线性表为空表。
==抽象数据结构==
ADT 2.1线性表ADT
ADT List{
数据∶
零个或多个数据元素构成的线性序列（aa，a;，…，an-1l）。数据元素之间的关系是一对一关系。
运算∶
	Init（L）∶初始化运算。构造一个空的线性表L，若初始化成功，则返回OK;否则返回 ERROR。
	Destroy（L）∶撤销运算。判断线性表工是否存在，若已存在，则撤销线性表L;否则返回 ERROR。
	IsEmpty（L）∶判空运算。判断线性表L是否为空，若为空，则返回OK;否则返回 ERROR。
	Length（L）∶求长度运算。若线性表L已存在，返回线性表工的元素个数;否则返回 ERROR。
	Find（L，i）∶查找运算。若线性表工已存在且0≤i≤n-1，则查找并返回线性表L中元素a;的值;
	否则返回 ERROR。
	Insert（L，i，x）∶插入运算。若线性表L已存在且-1≤i≤n-1，则在元素a;之后插人新元素x;当i=-1时，新元素插在头部位置。插入成功后返回 OK，否则返回ERROR。
	Delete（L，i）∶删除运算。若线性表工非空且0≤i≤n-1，则删除元素az，删除成功后返回OK，否则返回ERROR。
	Update（L，i，x）∶更新运算若线性表L已存在且0≤i≤n-1，则将线性表L元素a;的值修改为x;否则返回x;
	output(L):输出运算,若线性表L已存在,则输出线性表L中所有的数据元素,否则返回ERROR
}
### 2.2 线性表的顺序存储结构和实现
**我的评价是这就是数组,和数组没啥区别**
#### 顺序表的初始化
```c
bool init(List * L,int n)
{
    if(n>MAZSIZE)
    {
        return false;
    }
    L->data=(ElemType*)malloc(sizeof(ElemType)*MAZSIZE);
    L->length=n;
    srand(time(NULL));
    for(int i=0;i<L->length;i++)
    {
        L->data[i]=rand()%100+1;
    }
    return true;
}
```
#### 顺序表的输出
```c
//顺序表的输出
void output(List *L)
{
    for(int i=0;i<L->length;i++)
    {
        printf("%d ",L->data[i]);
    }
}
```
#### 顺序表中元素的查找
```c
//顺序表中元素的查找
bool findx(List *L,int i,int *x)
{
    //找第i个元素，然后用x返回
    if(i<0||i>=L->length)
        return false;
    *x=L->data[i];
    return true;
}
```
#### 顺序表中元素的插入
```c
//顺序表中元素的插入
//将元素i放到第i个位置
bool insert(List *L,int i,ElemType x)
{
    //先判断是否越界
    if(i>=L->length||i<-1)
        return false;
    //判满
    if(L->length==MAZSIZE)
    {
        return false;
    }
    for(int j=L->length-1;j>i;j--)
    {
        L->data[j+1]=L->data[j];
    }
    L->data[i]=x;
    L->length++;
    return true;
}
```
#### 顺序表中元素的删除
```c
// 顺序表元素的删除
bool delete(List *L,int i )
{
    //先判断是否越界
    if(i>=L->length||i<-1)
        return false;
    if(L->length==0)    
        return true;
    for(int j=i;j<L->length;j++)
    {
        L->data[j]=L->data[j+1];
    }
    L->length--;
}
```
#### 顺序表的撤销
```c
//顺序表的撤销
void destroy(List *L)
{
    L->length=0;
    free(L->data);
    return;
}
```
#### 主函数
```c
int main()
{
    int n;
    printf("请输入你要构建多长的顺序表\n");
    scanf("%d",&n);
    List L;
    init(&L,n);
    output(&L);
    int x,j;
    printf("\n请输入你要查找第几位元素\n");
    scanf("%d",&j);
    findx(&L,j,&x);
    printf("你要查找的为%d\n",x);
    printf("你要插入的元素和你要插入的位置\n");
    scanf("%d %d",&x,&j);
    insert(&L,j,x);
    output(&L);
    printf("\n请输入你要删除第几位元素\n");
    scanf("%d",&j);
    delete(&L,j);
    output(&L);
    return 0;
}
```
### 2.3.1代表头结点的单链表的定义和表示
#### 结构体定义
```c
/*定义一个链表里面可以存放数据以及指针域*/
typedef struct node{
    int element;
    struct node *link;   //自我调用，这个是个指针，为什么是结构体指针因为这个指针指向的是下一个结构体
}Node;
typedef struct headrlist
{
    Node *head;         //表头的定义
    int n;
}headrlist;
```
#### 初始化单链表
```c
/*表头节点的初始化*/
int Init(headrlist *h)
{
    h->head=(Node*)malloc(sizeof(Node));    //为表头申请空间，所占用的空间是一个Node所占用的
    if(!h->head)
        return ERROR;
    h->head->link=NULL;                    
    h->n=0;
    return OK;
}
```
#### 单链表的查找
```c
/*代表头节点的查找*/
int find(headrlist *h,int i,int *x)
{
    Node *q;
    int j;
    if(i<0||i>h->n)
        return ERROR;
    q=h->head;
    for(j=0;j<i;j++)
    {
        q=q->link;
    }
    *x=q->element;
    return x;
}
```
#### 单链表的插入
```c
/*带表头节点的插入*/
int insert(headrlist *h,int i,int x)             //在L的第i个位置上插入x
{
    Node *q,*p;
    int j;
    if(i<-1||i>h->n-1)                          //所以最开始只有当表头位于-1处才会往下进行
        return ERROR;
    p=h->head;
    for(j=0;j<i;j++)                            //当i=0的时候就是不用进行遍历，直接去寻找头结点就行
    {
        p=p->link;
    }
    q=(Node*)malloc(sizeof(Node));              //为q申请一个Node的空间
    q->element=x;
    q->link=p->link;                            //将元素插入给了一个q这个q并不是一个固定的东西，因为之后又会利用它进行插入
    p->link=q;                                  //唯一固定的是这个q用来申请的地址
    h->n++;                                     //这个n是元素的个数
    return OK;
}
```
#### 删除某个结点
```c
/*删除第i个元素*/
int delete(headrlist *h,int i)
{
    Node *q,*p;
    int j;
    if(!h->n)                                   //插入验证是否为满，删除验证是否为空
    {
        return ERROR;                           //只要插入一个元素那么n就不等于0了，所以会直接进行返回。
    }
    q=h->head;                                  //从头结点开始
    if(i<0||i>h->n-1)
        return ERROR;                            //判断其删除的位置是否在指针域里面
    for(j=0;j<i;j++)
    {
        q=q->link;                                      
    }                   //到达了要删除的位置的前一个元素
    p=(Node*)malloc(sizeof(Node));
    p=q->link;          
    q->link=p->link;
    free(p);
    h->n--;
    return OK;
}
```
#### 输出单链表
```c
/*输出带表头节点的链表元素*/
int output(headrlist *h)
{
    Node *q;
    int j;
    q=h->head;
    for(j=0;j<h->n;j++)
    {
        printf("%d  ",q->element);
        q=q->link;
    }
    return OK;
}
```
#### 撤销单链表
```c
/*撤销带表头节点的链表元素*/
void destroy(headrlist *h)
{
    Node *q;
    while (h->head)
    {
        q=h->head->link;            //这么做的目的是我们可以保存后端节点的位置，防止断链，一步一步的去进行释放空间
        free(h->head);
        h->head=q;                  
    }
}
```
### 2.3.4 单循环链表
单循环链表是另一种线性表链式存储方式,用单链表中最后一个结点的指针域存储头结点的地址，使得整个单链表形成一个环，这种头尾相接的单链表称为单循环链表


单循环链表的空表的条件是first=NULL
代表头结点的单循环链表为空表的条件是head->link=head
### 2.3.5双向链表
有两个指针域,一个指向前驱结点,一个指向后继节点
```c
typedef struct dunode{
	ElemType element;
	struct dunode *llink;
	struct dunode *rlimk;
}dunode,*dulist;
```
双向链表的插入

### 2.4 顺序表与链表的比较
==没有最好的数据结构,只有最适合的数据结构==
时间上: 顺序表和链表各有优点,顺序表的话,查找更加快捷,链表的话,插入和删除更加的快捷,
空间上: 顺序表需要预分配一定长度的存储空间,若存储空间预分配过大,将导致存储空间浪费,若存储空间预分配过小,将造成空间溢出的问题,链表不需要预分配空间,只要有可用的内存空间,链表中的元素个数就没有限制.
## 堆栈和队列
### 3.1.1堆栈ADT
堆栈（简称栈）是限定插入和删除操作都在表的同一端进行的线性结构。允许插入和删除元素的一端称为栈顶（top）、另一端称为栈底（bottom）
若栈中无元素，则为空栈
进出栈的顺序是后进先出，就像是一个只有一个口进的杯子一样，进去的在最下面，最后出来。
==堆栈分为两种，一种是顺序栈，一种是链式栈==
### 3.1.2 堆栈的顺序表示
堆栈的顺序表示可以用一维数组来实现，在顺序结构存储的堆栈中，maxsize-1为堆栈的最大栈顶位置下标，top为当前栈顶位置下标，顺序方式表示的栈，又称为顺序栈
#### 结构体
```c
typedef int Elemtype;
typedef struct stack{
    Elemtype *data;
    int Maxsize;
    int top;
}stack;
```
#### 创建一个堆栈
```c
//creat a quene
bool create_quene(stack *q,int size){
    q->data=(Elemtype *)malloc(sizeof(Elemtype)*size);
    if(!q->data){
        return false;
    }
    q->top=-1;
    q->Maxsize=size;
    return true;
}
```
#### 向栈顶插入一个元素
```c
//insert an element
bool insert_quene(stack *q,Elemtype e){
    if(q->top==q->Maxsize-1){
        return false;
    }//满了
    //插入到最后
    q->top++;
    q->data[q->top]=e;
    return true;
}
```
#### 判断是否为满
```c
//judge full
bool judge_full_stack(stack *q)
{
    if(q->top==MAX_SIZE-1)
        return true;
    return false;
}
```
#### 判断是否为空
```c
//judge empty
bool judge_empty_stack(stack *q)
{
    if(q->top==-1)
        return true;
    return false;
}
```
#### 取出栈顶元素
```c
//get top element;
bool get_top__stack(stack *q,int *x)
{
    if(!judge_empty_stack(q))
    {
        *x=q->data[q->top];
        return true;
    }
    return false;
}
```
#### 输出堆栈
```c
//output
void output(stack *q)
{
    int i=0;
    for(i=0;i<q->top+1;i++)
    {
        printf("%d ",q->data[i]);
    }
}
```
#### 删除一个堆栈并释放空间
```c
//destroy a stack
void destroy(stack *q)
{
    q->top=-1;
    q->Maxsize=0;
    free(q->data);
}
```
#### 删除栈顶元素
```c
// delete top element;
bool delete_top_element(stack *q)
{
    if(!judge_empty_stack(q))
    {
        q->top--;
        return true;
    }
    return false;
}
```
#### 删除元素但是不删除空间
```c
// delete all element but not free space
void destroy_element_not_sapce(stack *q)
{
    q->top=-1;
}
```
### 3.1.3 堆栈的链接表示
堆栈也可以用链接方式进行表示,此时栈顶的指针TOP指向栈顶元素节点,如图3.3所示,链接方式表示的栈又称链式栈,链式栈的定义和操作的实现,类似于单链表

top就类似于表头结点,然后每删除一个元素,top就后移一个元素,然后此时可以用一个中转的节点,来进行释放空间,插入元素同理,只在表头进行插入
### 3.2.1队列ADT
队列是限定在表的一端插人、在表的另一端删除的线性结构。其中，队尾（rear）为新元素依次进队的位置，而队头（front）则为队列中元素依次出队的位置.若队列中无元素，则为空队列。
队列为先进先出的线性数据结构,类似于两端开口的瓶子
### 3.2.2队列的顺序表示
front 为指向队头元素的前一单元的下标位置，rear 为指向队尾元素的下标位置，maxSize表示队列中最多允许存储的元素数量
元素人队时，先将队尾下标rear 加1，然后元素入队;元素出队时，先将队头下标 front 加1然后元素出队
在队尾rear处插入,为什么要先加1,因为此时指向的并不是一个空的位置
因为只让rear和front+1的话,会出现假溢出的问题,即当判定满了之后,其实并没有满.此时我们采用循环队列
front前进1个单元位置∶front=（front+1）%maxSize
rear 前进1个单元位置∶ rear=（rear+1）%maxsize
这种方法解决了假溢出的问题,但实际上还是有点问题的,就是这种队列满的时候,队列实际上仍然有一个元素的空间未被使用
==相关代码==
#### 结构体
```c
#define MAXSIZE 10
typedef int Elmetype;
typedef struct quene
{
    int Maxsize;
    int rear;
    int front;
    Elmetype *element;
}quene;
```
#### 初始化队列
```c
//init quene
void init_quene(quene *q,int size)
{
    q->element=(Elmetype*)malloc(sizeof(Elmetype)*size);
    q->front=0;
    q->rear=0;
    q->Maxsize=size;
}
```
#### 向队列中插入元素
```c
//insert element in quene
bool insert_quene(quene *q,Elmetype x)
{
    if((q->rear+1)%q->Maxsize==q->front)
    {
        return false;
    }
    q->rear=(q->rear+1)%q->Maxsize;
    q->element[q->rear]=x;
    return true;
}
```
#### 判满
```c
//judge full
bool judge_full_quene(quene *q)
{
    if((q->rear+1)%q->Maxsize==q->front)
    {
        return true;
    }
    return false;
}
```
#### 判空
```c
//judge empty
bool judge_empty_quene(quene *q)
{
    if(q->rear==q->front)
    {
        return true;
    }
    return false;
}
```
#### 销毁队列,然后释放空间
```c
//destroy a quene and free the space
void destrory_quene_space(quene *q)
{
    q->front=-1;
    q->rear=-1;
    q->Maxsize=0;
    free(q->element);
}
```
#### 读取队列的头元素
```c
//get the front element in quene
bool get_front_quene(quene *q,int *x)
{
    if(!judge_empty_quene(q))
    {
        x=q->element[(q->front+1)%q->Maxsize]; //just get a element not to move the front
        return true;
    }
    return false;
}
```
#### 删除队列的头元素
```c
//delete the front element in quene
bool delete_front_quene(quene *q,int *x)
{
    if(!judge_empty_quene(q))
    {
        q->front=(q->front+1)%q->Maxsize;
        return true;
    }
    return false;
}
```
### 3.3.1表达式的计算
中缀表达式
后缀表达式的区别
这一章多做一下题琢磨一下就好了
#### 后缀表达式的求值计算器
### 3.4.1递归的概念
本质上是一种循环的程序结构,它把叫复杂的计算逐次归结为,较简单的计算,一直归结到最简单的计算
使用递归方法定义的数据结构称为递归数据结构
### 3.4.2 递归的实现
递归算法的优点是明显的,程序非常简洁和清晰,且易于分析,但它的缺点是费时间,费空间

构造递归算法的时候我们要分析这个操作中哪些是重复性的操作,以及操作的终止条件是什么

## 数组和字符串
数组是一种连续存储的数据类型,常被用来实现数据的顺序存储结构.
每个数组所占存储空间大小一致,在已知数组存储空间首地址的前提下,通过数组下标可以实现对数组元素的随机存取
一旦为数组分配了存储空间，就不能增加或减少已分配存储空间，只能访问或修改数组元素值，因此数组是静态的数据结构
### 4.1.1一维数组
赋值,我们可以采用直接赋值**在定义的时候赋值**,也可以根据下标赋值.
在定义的时候直接赋值相比于循环下标赋值,效果最好,所用时间最短
==存储地址的计算==
可以通过数组下标快速计算出数组元素的存储地址美下标为i（0≤i<n）的数组元素
arrName[i]的存储地址 loc（arrName【i】）为
>loc(arrName[i])=loc(arrName[0])+i×sizeof(ElemType)(0≤i<n)

数组任意元素存储地址所耗费的时间都是相同的
存取数组任意元素所耗费的时间也是相同的，具有这种特点的存储结构称为随机存取的存储结构
### 4.1.2二维数组
和一维数组没啥区别,感觉都差不多
存储方式有两种行优先存储和列优先存储
#### 行优先存储
首先将数组第1行的所有数组元素依次存储到一维存储空间中，再将数组第2 行的所有数组元素依次存储到一维存储

#### 列优先存储
首先将数组第1列的所有数组元素依次存储到一维存储空间中，再将数组第2列的所有数组元素依次存储到一维存储

### 4.1.3 多维数组
根据一维二维依次类推
### 4.2 数组的抽象数据类型
```html
CreateArray (A,mi,m2,…,ma)
创建运算∶申请n维数组A.所需存储空间并分配给数组 A，成功分配则函数返回 oK;否则，函数返回 ERROR。
DestroyArray (A)
清除运算∶判断数组A是否存在，若存在，则撤销数组，函数返回 OK;否则，函数返回ERROR。
RetrieveArray (A,i,ia,·,i)
数组元素查询运算;判断数组A是否存在，若不存在，则函数返回ERROR;否则，对i，i，…，i。进行
边界检查，若下标非法，则函数返回 ERROR，否则返回下标为i，i2，…，i，的数组元素。
StoreArrayItem (A,ii,ia,…,i,x)
数组元素赋值运算∶判断数组A是否存在，若不存在，则函数返回ERROR;否则，对i;，ia，…，i，进行
边界检查，若下标非法，则函数返回 ERROR，否则将下标为i，iz，…，，i。的数组元素值设置为x，函数
返回 OK。
OutputArray (A)
数组输出运算;判断数组A是否存在，若不存在，则函数返回;否则，将数组中所有元素依次输出。
CopyArray (A,B)
数组复制运算∶判断数组A和B是否存在，若A或B不存在，则函数返回 ERROR;否则，判断数组A和B
是否大小相同（指每一个维度的大小都相同），若不同，则函数返回 ERROR，否则，将数组A中元素依次
复制到数组B中。
```
==三维数组的运算==

### 4.3特殊矩阵
在实际应用中，矩阵规模通常很大，为了节约存储空间，加快矩阵运算速度，需要对矩阵进行压缩存储。压缩存储的核心思想包括∶（1）对于值相同的多个矩阵元素，只为其中一个元素分配存储空间;（2）值为零的矩阵元素尽量不分配空间;(3）可实现无损解压，即矩阵中所有未分配存储空间的元素可以被完全恢复.
#### 4.3.1 对称矩阵
满足aij=aji的矩阵称为对称矩阵
在计算机实际存储一个对称矩阵时,只需要存储矩阵的上三角元素或下三角元素包括对角线的元素,因此包含了n * n个元素的对称矩阵,实际存储时只需要n* (n+1)/2个元素的存储空间,也就是说，在实际存储对称矩阵时，只需要一个长度为N的一维数组，N=n×（n+1）/2。

存储时我们要约定存储规则,是行优先还是列优先,存的是下三角还是上三角,不同情况,元素相对应的下标是不一样的.
**行优先存下三角**

**行优先存上三角**

#### 4.3.1 三角矩阵
和对称矩阵有点像,也是存了矩阵的一半,加上对角线,唯一的区别是,三角矩阵的另一半都是一个相等的一个常数,我们只需要记住这个常熟值就可以
存储时我们要约定存储规则,是行优先还是列优先,存的是下三角还是上三角,不同情况,元素相对应的下标是不一样的.
**行优先存下三角**


**行优先存上三角**

### 4.4 稀疏矩阵
#### 4.4.1 ADT抽象数据类型
```html
CreateSparseMatrix(A,m,n)
创建运算∶创建一个m×n 的空稀疏矩阵。
ClearSparseMatrix (A)
清除运算∶清除稀疏矩阵，成功清除，则函数返回 OK;否则，函数返回 ERROR。
StoreSparseMatrixItem (A,i,j,x)
赋值运算∶判断稀疏矩阵A是否存在，若不存在，则函数返回 ERROR;否则，设置稀疏矩阵中下标为
i，j的元素值为x，设置成功，函数返回 OK，否则，函数返回 ERROR。
RetrieveSparseMatrix(A,i,j)
查找运算∶判断稀疏矩阵A是否存在，若不存在，则函数返回 ERROR;否则，对i，j进行边界检查，若下
标非法，则函数返回 ERROR，否则，返回下标为i，j的元素。
OutputSparseMatrix(A)
输出运算∶判断稀疏矩阵A是否存在，若不存在。则函数返回;否则，将矩阵所有非零元素及其下标依次输出。
TransposeSparseMatrix(A)
转置运算∶判断稀疏矩阵A是否存在、若不存在，则函数返回 ERROR;否则、返回A 的转置矩阵。
AddSparseMatrix(A,B)
加法运算∶判断稀疏矩阵A和B是否存在，若A或 B不存在，则函数返回ERROR;否则。返回A和B之和。
MultiSparseMatrix(A,B)
乘法运算;判断稀疏矩阵A和B是否存在，若A或B不存在，则函数返回ERROR;否则，返回A和B之积。
```

相比于前面两种特殊矩阵,稀疏矩阵没啥特色,唯一的特色就是零比较多
非零元素数量占元素总数的比例称为矩阵的稠密度。稠密度很小，即包含大量零元素的矩阵称为稀疏矩阵（sparse matrix）。通常稠密度小于5%矩阵即可视为稀疏矩阵。与特殊矩阵不同，稀疏矩阵中零元素的位置分布没有规律。

这种矩阵的存储,很明显我们要存取所有的非零元素,而又由于零元素存的没有规律,所以,我们在存储的时候必须讲位置信息也存上 
和前面两种特殊矩阵的存储一样,这个稀疏矩阵的存储也是有行优先存储和列有限存储两个方面的
#### 4.4.2稀疏矩阵的转置算法
==三种方法==
##### 稀疏矩阵转置算法1
分为两步
1. 依次访问行三元组表中的各个三元组i  j aij 交换元素的行列号后将其依次保存到B的行三元组表中
2. 将B的行三元组表中的行三元组按照下标i值从小到大重新排序

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>
#define ROW 20
#define LINE 3
#define maxsize 100
typedef int ElemType;
typedef struct  term
{
    int col;
    int row;
    ElemType value;
}term;
typedef struct sparesematrix
{
    int m,n,t;              //m 是矩阵行数，n是矩阵列数，t是非零元素的个数
    term table[maxsize];
}sparesematrix;

int count=0;//all element;
//contruct a sparse matrix
ElemType **creat(ElemType **a,int n)
{
    a=(ElemType **)malloc(sizeof(ElemType*)*n);
    int i=0,j=0;
    for(i=0;i<n;i++)
    {
        a[i]=(ElemType*)malloc(sizeof(ElemType)*n);
    }
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            if(rand()%4+0>=1)
                a[i][j]=0;
            else{
                a[i][j]=rand()%9+2;
                count++;
            } 
        }
    }
    return a;
}
//output the sparse matrix
void output(ElemType **a,int n)
{
    int i,j;
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }
}
//transfer elements fronm sparse matrix to array
void trsnsfer(ElemType **a,sparesematrix *A,int n)
{

    A->m=n;
    A->n=n;
    A->t=count;
    int i,j,k=0;
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            if(a[i][j]!=0)
            {
                A->table[k].col=i;
                A->table[k].row=j;
                A->table[k].value=a[i][j];
                k++;
            }
        }
    }
}
//行三元组的转置算法
void transpose(sparesematrix *A,sparesematrix *B)
{
    int i=0,j=0;
    B->m=A->m;
    B->n=A->n;
    B->t=A->t;
    //exchange i and j
    for(i=0;i<A->t;i++)
    {
        B->table[i].col=A->table[i].row;
        B->table[i].row=A->table[i].col;
        B->table[i].value=A->table[i].value;
    }
    //按照下标i的值进行排列
    term temp;
    int k=0,index=0;
    //row
    for(i=0;i<B->t;i++)
    {
        //line
        for(k=0;k<B->t;k++)
        {
            if(B->table[k].col==i)
            {
                for(j=0;j<B->t;j++)
                {
                    if(B->table[k].row==j)
                    {
                        temp=B->table[k];
                        B->table[k]=B->table[index];
                        B->table[index]=temp;
                        index++;
                    }
                }
            }
        }
    }
    
}
int main()
{
    //contruct a matrix
    int **a;
    int n;
    printf("请输入你想构建多少层的稀疏矩阵\n");
    scanf("%d",&n);
    a=creat(a,n);
    output(a,n);
    sparesematrix A,B;
    trsnsfer(a,&A,n);
    printf("其行三元组为\n");
    for(int i=0;i<count;i++)
    {
        printf("%d %d %d ",A.table[i].col,A.table[i].row,A.table[i].value);
        printf("\n");
    }
    transpose(&A,&B);
    printf("其转置后三元组为\n");
    for(int i=0;i<count;i++)
    {
        printf("%d %d %d ",B.table[i].col,B.table[i].row,B.table[i].value);
        printf("\n");
    }
    return 0;
}
```

##### 快速转置算法
```c
void fast_transpose(sparesematrix *A, sparesematrix *B)
{
    int *num,*k;
    k=(int *)malloc(sizeof(int)*A->t);
    num=(int *)malloc(sizeof(int)*A->t);
    for(int j=0;j<A->t;j++)
    {
        num[j]=0;
    }
    for(int i=0;i<A->t;i++)
    {
        num[A->table[i].col]++;     //列中存在元素就加一
    }
    for(int j=0;j<A->t;j++)
    {
        k[j]=0;
    }
    for(int j=1;j<A->t;j++)
    {
        k[j]=k[j-1]+num[j-1];
    }
    for(int i=0;i<A->t;i++)
    {
        int index=k[A->table[i].col]++;
        B->table[index].col=A->table[i].row;
        B->table[index].row=A->table[i].col;
        B->table[index].value=A->table[i].value;
    }
}
```
### 4.5简单字符串匹配算法
一趟一趟的将主串和模式串进行匹配,每趟匹配都与模式串p依次比较各个字符,发生失配时,本躺匹配失败,从主串的下一个位置和模式串的第一个位置开始,下一趟匹配
```c
int Index(String s,String p,int pos)
{
	int s_start,p_start=0, s_ fail, p_fail;
	for(s_start =pos; s_start<=s.length-p.length;s_start++)
	{
		if(Match(s,p,s_start,p_start,&s_fail,6p_fail))
			return s_start;
	}
	return -1;
}
B00L Match(String s,String p,int s_start,int p_start,int*s_fail,int*p.fail)
{
//从模式串 p_start 位置与主串的s_start 位置开始进行匹配
	int i=s_start,j=p_start;
	for(;j<p.length; i++,j++)
	{
		if(s.str[i] != p.str[])	
		{
			*s_ fail = i;//s_ fail记录主串失配位置
			*p_fail =j;// p_fail记录模式串失配位置
			return FALSE;
		}
	}
	return TRUE;
}
```



### 4.6KMP算法
原本匹配的时主串的i++和子串的j++,不断的自加,然后进行匹配,之后,当匹配失败后主串位置不动,改变子串的位置,让j移动到前缀后以为 ,在让此时的i和j比较,这就是KMP算法的基本原理


```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#define Maxsize 256
typedef struct string
{
    char str[Maxsize];
    int length,maxlength;
}String;
void Fail(String p,int *fail)
{
    int j=0,k=-1;
    fail[0]=-1;
    while (j<p.length) {
        if(k==-1||p.str[k]==p.str[j])
        {
            k++;
            j++;
            fail[j]=k;
        }else k=fail[k];
    }
}
bool Match(String s,String p,int s_start,int p_start,int*s_fail,int*p_fail)
{
//从模式串 p_start 位置与主串的s_start 位置开始进行匹配
	int i=s_start,j=p_start;
	for(;j<p.length; i++,j++)
	{
		if(s.str[i] != p.str[j])	
		{
			*s_fail = i;//s_ fail记录主串失配位置
			*p_fail =j;// p_fail记录模式串失配位置
			return false;
		}
	}
	return true;
}
int KMPindex(String s,String p,int pos,int *fail)
{
    int s_start=0,p_start=0,s_fail,p_fail;
    while (s_start<=s.length-p.length) {
        if(Match(s, p, s_start,  p_start, &s_fail, &p_fail))
            return s_start-p_start;
        else {
            p_start=fail[p_fail];
            s_start=s_fail;
            if(p_start==-1)
            {
                p_start=0;
                s_start++;
            }
        }
    }
    return -1;
}
```



## 树
### 5.1.1 树的定义
> 为什么要学习树呢

1. 层次结构数据在现实世界中大量存在。许多应用程序需要处理具有层次关系的数据。

2. 我们前面所学的线性关系的数据结构,并不适合表示层次结构的数据,即线性结构的数据通常都是一对一,但是当我们遇到一对多的情况的时候就出现了困难

> 树的种类

常见的树的有---树,二叉树,堆,哈夫曼树
> 树的定义

1. 定义5.1 树是包括n（n≥0）个结点的有限集合D，R是由D中元素构成的序偶的集合。若D 为空，则R也为空，此时该树为空树。

2. 树可以为空集,对于非空树而言，至少有一个根节点，根节点没有前驱节点，其余节点都有唯一的前驱节点，因此树具有层次结构特点

> 树的递归性

1. 我们通过子树来定义树,在树的定义中引用了树概念的本身,所以,树具有递归结构特征

> 基本术语

1. 节点---树中的元素常称为节点

2. 边---根和它的子树根（如果存在）之间形成边的边可到达另一个结点，则称这两个结点间存在一条路径。

3. 双亲---若一个结点有子树，那么该结点称为子树根的双亲

4. 孩子---子树的根是该结点的孩子

5. 兄弟---有相同双亲的结点互为兄弟

6. 后裔---一个结点的所有子树上的任何结点都是该结点的后裔

7. 祖先---从根结点到某个结点路径上的所有结点都是该结点的祖先

8. 度---一个结点拥有的子树数量称为该结点的度。度为0的结点称为叶子结点，树中结点的最大的度称为树的度

9. 层次---一般将根节点的层次定义为1,其余节点的层次等于其双亲结点的层次加1,书中节点的最大层次称为该树的高度

10. 无序树,有序树,如果一棵树中各结点的子树的次序不重要，可以交换位置，这样的树称为无序树。如果将树中结点的各棵子树看成是从左到右有次序的，则称该树为有序树。从左到右，可分别称这些子树为第一子树、第二子树等。

11. 森林---森林是树的有限集合

### 5.2 二叉树

#### 5.2.1 二叉树的定义

> 定义

1. 二叉树是结点的有限集合，该集合或者为空集，或者由一个根和它互不相交的、同为二叉树的左子树和右子树组成。

> 二叉树的五种形式

![2022-11-23-19-26-27-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011713046.png)

> 注意点

1. 树可以是无序的,二叉树要区分左右子树的,即使在一棵子树的情况下也要指明

2. 二叉树的每个节点最多只有两棵子树

3. 上一节树的术语,在这一节同样适用

#### 5.2.2 二叉树的性质
> 性质

1. 性质5.1 二叉树的第i（i≥1）层上最多有**2^(i-1)个结点。**

2. 性质5.2 高度为h的二叉树上至多有2^h-1个结点。

3. 性质5.3 包含n个结点的二叉树的高度至少为【log2（n+1）】，最高为n

![2022-11-23-19-32-23-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011713882.png)

4. <mark>重点，要做到自己能够熟练的推理</mark>

![2022-11-23-19-32-38-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011713413.png)

![2022-11-23-19-37-32-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011714488.png)

5. 高度为h的二叉树恰好有2^-1个节点时称为满二叉树

6. 一颗二叉树中，只有最下面两层节点的度可以小于2，并且最下层的叶节点集中在靠左的若干位置上，这样的二叉树称为完全二叉树**叶子节点都在同一层，只有最下两层节点可以左右子树只存在左子树，存在一个可以，但是只能时左子树**

7. 不存在度为1的结点的二叉树成为扩充二叉树，又称为2-树

> 完全二叉树的性质

1. 具有n个结点的完全二叉树的高度为【log2（n+1）】。
   设完全二叉树的高度为h，则除最下层外，前h-1层形成满二叉树，总共有2^(h-1)-1个结点；而最下层，即第h层的结点个数不超过2^(h-1)个。因此有
   
   ![2022-11-23-19-42-36-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011714969.png)

2. <mark>超级重点，树中节点和遍历的位置关系</mark>

![2022-11-23-19-43-55-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011714307.png)
#### 5.2.3 二叉树ADT
>  抽象数据结构类型定义二叉树

1. Create（bt）构造一棵空二叉树bt。

2. NewNode（x，ln，rn）∶创建一个新结点，该结点的值为x，1n和rn为该结点的左右孩子结点。

3. IsEmpty（bt）∶若二叉树bt为空，则返回TRUE，否则返回FALSE。

4. TreeClear（bt）∶清除二叉树bt中的所有结点，使之成为空二叉树。

5. Root （bt，x）∶若二叉树bt非空，则用x返回其根结点的值，并返回TRUE，否则返回FALSE。

6. MakeTree（bt，x，left，right）∶构造一棵二叉树bt，根结点的值为x，以left和right为该根结点的左右子树。

7. PreOrderTree（bt）∶先序遍历二叉树bt。InOrderTree（bt）∶中序遍历二叉树bt。PostorderTree（bt）∶后序遍历二叉树bt。LevelorderTree（bt）∶层次遍历二叉树bt。

> 二叉树的结构体

```c
//二叉树的节点结构体
typedef char ElemType;
typedef struct btnode
{
    ElemType element;
    struct btnode *lchild;    //存储左节点
    struct btnode *rchild;    //存储右节点,在二叉树中重复适用结构体,一定要时全称
    //因为此时的typedef还没执行到,所以别名尚未定义
}btnode;
//二叉树的结构体
typedef struct binarytree
{
    btnode *root;             //用来直接调用树更加方便,只需要调用binarytree即可
}binarytree;
```

> 创造一个新的空二叉树

```c
void craet(binarytree *bt)
{
    bt->root=NULL;              //对于一个树来说，我们只需要创造一个根节点即可
}
```

> 创造树的节点

```c
//创造树的节点
btnode *newnode(ElemType x,btnode *ln,btnode *rn)
{
    btnode *p=(btnode*)malloc(sizeof(btnode));      //新建一个节点，以便于我们能够返回
    p->root->element=x;
    p->root->lchild=ln;
    p->root->rchild=rn;
    return p;
}
```

> 判断是否为空

```c
bool isempty(binarytree *bt)
{
    if(bt->root)
        return true;
    else return false;
}
```

> 清空二叉树

```c
//清除二叉树中的所有节点，使其成为空二叉树 
//清除就涉及到遍历，遍历树就涉及到递归 
void cleartreemain(binarytree *bt) 
{ 
cleartree(bt->root); 
} 
void cleartree(btnode *p) 
{ 
if(!p) 
return; 
cleartree(p->lchild); 
cleartree(p->rchild); 
free(p); 
}
```

#### 5.2.4二叉树的存储表示

> 完全二叉树的存储表示

1. 完全二叉树的存储和普通的二叉树的存储有区别,因为完全二叉树的层次结构时严格的,所以我们可以直接利用顺序结构进行存储,顺序结构存储的完全二叉树满足以下性质

![2022-11-23-20-24-42-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011715141.png)

根据性质5.6，如果已知一个结点的位置，可方便地计算出它的左、右孩子和双亲的位置，这说明该存储方式能够完全反映一棵二叉树的结构信息，且访问效率高。

**但是顺序存储不适用于普通的树的存储,普通树的存储我们可以采用链表的方法进行存放**

> 二叉树的链接表示

![2022-11-23-20-28-01-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011715311.png)

一棵包含n个结点的二叉树中，除根结点外，其余每个结点均有一个出自某个指针域的指针指向该结点，因此，共有n-1个指针域非空。二叉链表结构中，指针域的数目为2*n所以恰好有n+1个空指针域

<mark>二叉树的链接存储的优缺点</mark>

二叉树的二叉链表结构有利于自上而下从双亲到孩子方向的访问。如果已知二叉树的一个结点，要查找其双亲结点，在该结构下只能从根结点开始，遍历整个二叉树来实现，这显然是费时的。这类似于已知单链表的一个结点 为了得到其前驱结点，只能从表头开始查找。如果应用程序需要经常执行从孩子到双亲方向的访问，可在二叉链表结点中增加一个 parent 域，令其指向该结点的双亲结点。这就实现了从孩子到双亲，以及从双亲到孩子的双向链接

**是否加入这些双亲节点取决于我们函数的主要功能时什么**

### 5.3 二叉树的遍历

#### 5.3.1二叉树遍历的递归算法

> 三种递归遍历

1. 我们定义了二叉树的四种遍历运算，即先序遍历、中序通历、后序遍历和层次遍历。其中先序遍历、中序遍历和后序遍历的设计思想与二叉树的递归定义密切相关

> 层次遍历

1. 层次遍历是利用二叉树中各结点所在的层次，按照从上到下、从左到右的顺序访问二叉树中的每一个结点。

> 先序,中序,后序遍历

1. 对于这三种遍历方法而言,遍历的逻辑是没有什么区别的,唯一的区别在于,什么时候输出

2. 函数的递归调用,就是函数的自身调用,执行完之后会返回上一个被嵌套的函数,去执行,未执行的表达式

3. 假设L、V和R分别代表遍历左子树、访问根结点和遍历右子树这三个操作，那么就可以得到六种遍历次序，分别是VLR、LVR、LRV、VRL、RVL 和 RLV。

4. 即先访问根结点的先序遍历 VLR、中间访问根结点的中序遍历 LVR 和最后访问根结点的后序遍历 LRV

> 三种遍历算法的总结

1. 先序遍历算法读取的时候输出是在第一个，也就是说每次执行函数都会有输出，其是先从根节点开始的，然后遍历左子树，和右子树，所以它的结果一般是，从根节点开始输出，然后不断输出根节点的左子树内容，然后是到最下面的左子树结点的时候，判断有没有左右子树，没有的话，判断上一个有没有右子树，有的话先输出右子树，然后在继续判断有没有左子树，，，，

2. 中序遍历算法输出在遍历左子树之后，到最下面一个左子树才开始输出，然后是判断其有没有右子树，没有的话，返回上一步，此时上一步的遍历左子树算法结束，然后输出结点，然后继续遍历右子树，如果是先序遍历的话，此时这个右子树会输出的，但是中序遍历却不会输出，而是继续判断这个右子树有没有左子树之后才会输出。这就是区别

3. 后序遍历，就是先到最下方的一个左子树，然后是返回上一个节点，此时先序和中序，都会输出上面的结点，但是后序不会，后序的话，是只有子树输出完了，才会输出双亲结点

> 先序遍历代码

```c
//先序遍历算法的主算法
void preorder(btnode *t)
{
    if(!t)
        return;
    printf("%c",t->element);
    preorder(t->lchild);        //遍历左子树
    preorder(t->rchild);        //遍历右子树
    return;    //先序遍历的算法和中序后序遍历算法都是一样的,区别就在于printf的位置不同
}
//从根节点开始引入函数
void preordermain(binarytree *bt)
{
    preorder(bt->root);
}
```

> 二叉树的层次遍历

1. 二叉树还可以按层次进行遍历。层次遍历是利用二叉树中各结点所在的层次位置，按照从上到下、从左到右的顺序访问二叉树中的每一个结点

> 算法步骤

1. 首先访问第一层中的根结点，然后按照从左到右的顺序访问第二层中的结点，以此类推，接着访问二叉树中第三层直至最后一层中的所有结点。

2. <mark>层次遍历之后树的结构被破坏</mark>

> 利用队列来存储数据

![2022-11-24-16-34-55-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011715017.png)

> 队列函数代码区

```c
typedef struct quene
{
    int front;
    int rear;
    int maxsize;
    btnode *element;
}quene;
//队列结构体的定义
//创造一个能容纳maxsize的队列
void creatquene(quene *Q,int maxsize)
{
    Q->element=(btnode*)malloc(sizeof(btnode)*maxsize);     //为存储节点申请动态空间
    Q->front=0;
    Q->rear=0;
    Q->maxsize=maxsize;
}
//判断队列是不是满了
bool isfull(quene *Q)
{
    return (Q->rear+1)%Q->maxsize==Q->front;
}
//判空
bool isemptyquene(quene *Q )
{
    return Q->front==Q->rear;
}
//在队尾插入x,入队操作
bool inser_trear(quene *Q,btnode *p)
{
    if(isfull(Q))
        return false;
    Q->rear=(Q->rear+1)%Q->maxsize;
    Q->element[Q->rear]=*p;      //队列中的存储元素存储的是节点数组，所以存储的时候这个地方应该是节点，而不是节点的地址
    return true;
}
//获取队列的头元素
bool get_front(quene *Q,btnode *x)
{
    if(isemptyquene(Q))
        return false;
    *x=Q->element[(Q->front+1)%Q->maxsize];
    return true;
}
//删除队头的元素
bool delete_front(quene *Q)
{
    if(isemptyquene(Q))
        return false;
    Q->front=(Q->front+1)%Q->maxsize;
    return true;
}
//删除所有的元素，但是并不删除空间
void destroy_all(quene *Q)
{
    Q->front=Q->rear;
}
```

> 层次遍历代码区

```c
    //层次遍历
void cengci_order(binarytree *bt)
{
    //判断树是否未空
    if(!bt->root)
        return;
    quene Q;
    creatquene(&Q,QUEUSESIZE);     //创建一个新的队列
    btnode *p=bt->root;  
    inser_trear(&Q,p) ;            //将根节点入队
    while (!isemptyquene(&Q))
    {
        get_front(&Q,p);
        delete_front(&Q);
        printf("%c",p->element);
        if(p->lchild)
            inser_trear(&Q,p->lchild);
        if(p->rchild)
            inser_trear(&Q,p->rchild);
    }
    destroy_all(&Q);
}
```

#### 5.3.2 二叉树遍历的实用举例

#### 1. 计算二叉树中节点的个数

递归的思想

调用Size（t->IChild）和Size（t->rChild）可以分别计算t的左、右子树的结点数量,最后加上根节点的数量就是总子树的数量

```c
int COUNTNODE=0;    //定义了一个全局变量
//计算树中节点的个数
void countnode(btnode *t)
{
    if(!t)
        return;
    COUNTNODE++;
    countnode(t->lchild);
    countnode(t->rchild);
    return;
}
void countnodemain(binarytree *bt)
{
    countnode(bt->root);
}
//主函数的调用
countnodemain(&z);
printf("\n%d",COUNTNODE);
```

#### 2.清空二叉树

> 算法

```c
void cleartree(btnode *p)
{
    if(!p)
        return;
    cleartree(p->lchild);
    cleartree(p->rchild);
    free(p);
}//free是可以释放指针的,不止仅仅可以释放动态空间,数组也是可以释释放的
void cleartreemain(binarytree *bt)
{
    cleartree(bt->root);
}
```

#### 3, 先序构建二叉树

二叉树的先序、中序和后序遍历算法都是递归算法，利用遍历算法也可以构建二叉树。下面，我们给出采用先序遍历方法构建二叉树的算法实现，

修改算法,我们可以选择性的构造树,第一种是通过输入构建树,第二种是通过一步一步的搭建构建树

> 先序遍历构建二叉树

```c
//利用先序递归算法构建树
btnode *creat_by_input(btnode *t)
{
    char ch=0;
    printf("请输入节点的元素");
    //为什么这个地方需要加入getchar呢
    getchar();
    scanf("%c",&ch);
    if(ch=='#')       //#是终止信号
    {
        t=NULL;
    }else {
        //对于指针而言，其是否申请动态空间，取决于其是否存放数据，如果只是简单的替换，那么就不需要申请
        //如果是需要存放数据，那么也不需要申请
        t=(btnode*)malloc(sizeof(btnode));
        t->element=ch;
        t->lchild=creat_by_input(t->lchild);
        t->rchild=creat_by_input(t->rchild);
    }
    return t;
}
void creat_by_input_main(binarytree *bt)
{
    bt->root=creat_by_input(bt->root);
}
```

> 层次遍历构建二叉树

```c
    while (index)
    {
        printf("输入该节点对应的子节点,如果节点为空就输入NULL\n");
        char ch1,ch2;
        getchar();
        scanf("%c %c",&ch1,&ch2);
        p->lchild=(btnode*)malloc(sizeof(btnode));
        p->rchild=(btnode*)malloc(sizeof(btnode));
        p->lchild->element=ch1;
        p->rchild->element=ch2;
        inser_trear(&R,p->lchild);
        inser_trear(&R,p->rchild);
        delete_front(&R);
        get_front(&R,p);
        printf("终止请输入0否则输入任意值\n");
        scanf("%d",&index);
    }//备份
```

#### 5.3.3二叉树遍历的非递归算法

递归函数结构清晰，使程序易读。但递归函数也有不可克服的弱点，时间、空间效率较低，运行代价较高，所以在实际使用中，常希望使用它的迭代版本。

为了实现非递归遍历算法，需要一个堆栈作为实现算法的辅助数据结构。

二叉树是非线性数据结构，遍历过程中访问的每一个结点都有左、右两棵子树，任何时刻程序只能访问其中之一，程序必须保留以后继续访问另一棵子树的"线索"，我们用堆栈来存放这种线索线索。

1. BTNode* GetFirst（BinaryTree * bt， Stack* s），该函数负责返回二叉树bt中第一个被访问的结点，若二叉树为空，则返回NULL。

2. ）BTNode* GetNext （BTNode *current， Stack *s），该函数负责返回当前遍历次序下的被访问结点 current 的后继结点，如果不存在后继结点，则返回NULL。

3. void Traverse（BinaryTree *bt），该函数利用循环结构非递归地访问二叉树bt 中的每个结点，且只访问一次。

```c
//堆栈的一些操作
//创建一个能容纳msize的堆栈
void creatstack(stack *s,int msize)
{
    s->maxsize=msize;
    s->element=(btnode *)malloc(sizeof(btnode)*msize);
    s->top=-1;
}
bool isfullstack(stack *s)
{
    return s->top==s->maxsize-1;
}
//在栈顶的位置插入元素x
bool inserttopstack(stack *s,btnode *x)
{
    if(isfullstack(s))
        return false;
    s->top++;
    s->element[s->top]=*x;
    return true;
}
//判断是否为空的堆栈
bool isemptystack(stack *s)
{
    return s->top==-1;
}
//获取栈顶的元素
bool gettopstack(stack *s,btnode *a)
{
    if(isemptystack(s))
        return false;
    *a=s->element[s->top];
    return true;
}
//删除栈顶的元素
bool deltopstack(stack *s)
{
    if(isemptystack(s))
        return false;
    s->top--;
    return true;
}
```

```c
//非递归遍历算法
//将树从根节点开始的所有左子树都放在堆栈里，并将指针指向最左边的节点
btnode *getfirst(binarytree *bt,stack *s)
{
    btnode *p=bt->root;
    if(!p)
    {
        return NULL;
    }
    while (p->lchild!=NULL) //此处用！=NULL而不是用p是为了让我们返回值，否则的话，返回的是NULL
    {
        inserttopstack(s,p);
        p=p->lchild;
    }
    return p;       //最后p就是最左边，最下方的结点
}
//先判断这个指针有没有右子树，有的话就判断这个右子树有没有左子树，如果有那么同样是入栈操作
btnode *getnext(btnode *current,stack *s)
{   
    btnode *p;
    if(current->rchild!=NULL)
    {
        p=current->rchild;
        while (p->lchild!=NULL)
        {
            inserttopstack(s,p);
            p=p->lchild;
        }
        current=p;
    }
    else if (!isemptystack(s))
    {
        gettopstack(s,current);
        deltopstack(s);
    }
    else{
        current=NULL;
        return NULL;
    }
    return current;
}
//非递归遍历的主算法
void traverse(binarytree *bt)
{
    stack S;
    btnode *current;
    creatstack(&S,STACKSIZE);    //构建一个堆栈
    current=getfirst(bt,&S);
    while (current)
    {
        printf("%c",current->element);
        current=getnext(current,&S);
    }
    printf("\n");
}

=getnext(current,&S);
    }
    printf("\n");
}
```

#### 5.3.4线索二叉树的基本概念和构造

> 略，这个不在考纲范围

### 5.4 树和森林//不要求代码掌握

#### 5.4.1 森林和二叉树的转换

前面我们已经对二叉树进行了深入研究，如果树和森林能够用二叉树表示，那么二叉树的相关成果（如存储方法、遍历方法等）便可应用于树和森林

森林（或树）和二叉树之间有着一种自然的对应关系，我们可以将任何森林或树表示成唯一的二叉树，一棵二叉树也可以转换成对应的森林或树。

森林是有许多树大于等于1组成的。

**森林转化为二叉树**

1. 将根节点连起来，将后一个二叉树作为前一个二叉树的右节点

2. 将兄弟节点连起来，只保留最左边兄弟节点与双亲节点的连线，其他兄弟节点与双亲的连线删除。

3. 调整样式

4. 上述转换步骤采取的是递归的执行方式

5. 当F中只有唯一的树时，上述执行过程同样适用。因此，上述转换方法也适用于树到二叉树的转换，有的树不止有两个节点的

> 示例

![2022-11-26-16-56-47-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011715987.png)

**二叉树转化为森林**

如果将上述森林到二叉树的转换过程进行逆转，则可以将任意二叉树转换为其对应的唯一森林。

**先执行二叉树转化为树的操作**

1. 加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点，右孩子的右孩子结点，右孩子的右孩子的右孩子结点，反正就是左孩子的n个右孩子结点都作为此节点的孩子，在将该结点与这些右孩子节点用线连起来

2. 删除原二叉树中所有节点与其他右孩子节点的连线

3. 层次调整

![2022-11-26-17-15-42-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011716340.png)

判断二叉树是转化为一棵树还是一个森林，标准就是看这颗二叉树的根节点有没有右孩子，有就是转化为森林，没有就是一棵树

**二叉树转化为森林**

1. 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。

2. 再将每颗分离后的二叉树转化为树即可

![2022-11-26-17-17-24-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011716389.png)

**上述森林与二叉树之间转换过程的定义都是递归的， 它们都首先定义一种简单情况下的转换办法，即若二叉树为空，则对应的森林也为空，反之亦然**

#### 5.4.2 树与森林的存储表示

树是非线性数据结构，一般采用链接方式存储，但也存在着其他的存储方法

我们重点讨论树和森林的五种存储表示方法∶多重链表表示法、孩子兄弟表示法、双亲表示法、三重链表表示法和带右链的先序表示法

> 多重链表表示法

在计算机内表示一棵树的最直接的方法是多重链表表示法，即每个节点包含多个指针域，存放每个孩子节点的地址。每个结点的指针域数量应设定为树的度 m，即树中孩子数最多的结点的度

![2022-11-26-18-39-05-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011716477.png)

*总结：*

包含多个指针域且结点长度固定的链接结构称为多重链表。

设度为 m的树中有n个结点，每个结点有m个指针，总共有n×m个指针域，其中，只有n-1个非空指针域，其余n×m-（n-1）n（m-1）+1个指针域均为空。

可见多重链表发有浪费存储空间的问题，但这种方法的好处是结构简单，且易于实现

> 孩子兄弟表示法

孩子兄弟表示法本质上就是利用树和森林能够转化为唯一的二叉树这一性质设计的存储方法

![2022-11-26-18-46-10-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011716629.png)

child域是指向该节点的左孩子，element是元素，sibling是指向该节点的右兄弟

*例如下图：*

E是D的左孩子，F是E的右兄弟，G是E的右兄弟

![2022-11-26-18-48-19-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011716229.png)

> 双亲表示法

*链表的一个很大的一个特色就是正着来可以，反着来就不好弄了，具有单向的特征，解决这一问题的办法是我们可以通过构建双向的链表*

利用多重链表表示法和孩子兄弟表示法，都能够方便地从双亲结点查找到孩子结点。但在某些应用场合，可能需要通过孩子结点获得其双亲结点，此时，就可以采用双亲表示法来存储树或森林。

双亲表示法的每个结点有两个域，即 element 和 parent。parent用于指向当前结点的双亲结点，根结点没有双亲。

我们使用一个连续的存储区（如数组）来存储树或森林，下标代表结点位置，根结点的 parent 域为-1，其他结点的 parent 域是其双亲结点的下标;且树或森林中的结点按照从上到下、从左到右的次序存储。

*利用数组存放元素，感觉没太大的用处，就是将parent的指针域存放到一个指针数组中，通过调整数组中下标来选择parents域*

![2022-11-26-19-01-58-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011717117.png)

> 三重链表表示法

如果既想方便地从双亲查找孩子，又想方便地从孩子查找双亲，则可以将双亲表示法和孩子兄弟表示法结合起来

即在孩子兄弟表示法的每个结点中增加一个parent域，用于指向当前结点的双亲结点，这就是三重链表表示法。

在该存储表示方法中，每个结点有三个指针链域，从而形成三重链表，

![2022-11-26-19-05-17-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011717456.png)

*这个感觉比双亲链表表示法更好用*

> 带友链的先序表示法

带右链的先序表示法是将树或森林所对应的二叉树中的结点，按先序遍历的访问次序，依次存储在一个连续区域中，每个结点对应该连续区域中的一个单元，每一个单元包含三个域，分别是 sibling、element 和ITag

sibling 用于存储当前结点的第一个右兄弟结点的位置，当其为-1的时候没有右兄弟

element用于存储当前结点的数据;

ITag 用于标识当前结点是否有孩子结点，若ITag=1，表示没有孩子结点，若ITag=0，表示当前结点有孩子结点，

**上述的五种存储表示方法均可以用于存储树和森林，但各有特色，因此在实际应用中，需结合具体需求，设计并使用合理的存储表示方法**

#### 5.4.3树和森林的遍历

##### 1.按深度的方向的遍历

> 树的遍历

树的遍历只有两种方式,一种是前序遍历,一种是后序遍历,没有了中序遍历的形式,因为对于树来说,其可能有多个节点,不知道哪个节点能够作为其的中序

<mark>其先序遍历</mark>是先读取根节点,然后一次读取根节点的子树

<mark>后序遍历</mark>是先读取最左边的子树的最下方的左节点,然后是将所有的子树读完之后,才读取根节点

![2022-11-27-11-17-33-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011717244.png)

其先序遍历就是    DEHFJG

后序遍历就是HEJFGD

**树的遍历是递归遍历算法,一般来说,我们根据树的不同的存储表示,来进行添加遍历函数,对于常见比较好理解的多重链表表示法来说,就是像遍历二叉树一样,不过二叉树是只有左右节点两个遍历函数,这里是n个遍历函数**

> 森林的遍历

森林的遍历和树的遍历是有区别的

森林的遍历有先序中序后后序遍历算法,

其一个森林被分为了三部分,第一部分是第一棵子树的根节点,第二部分是第一棵树的根节点的子树,第三部分是森林中的其他树.

先序和中序和后序,就是对这三部分的不同顺序的遍历情况,其中先遍历第一第一部分的成为先序遍历算法.

<mark>中序遍历算法</mark>

若森林为空，则遍历结束。

否则∶①按中序遍历方法，遍历第一棵树的根结点的子树构成的森林;

②访问第一棵树的根;

③按中序遍历方法，遍历除了第一棵树以外的树构成的森林。

##### 2.按层次方向的进行遍历

其实这个类似于我们二叉树的遍历中的层次遍历

**定义**首先按照从左到右的次序，访问处于第一层的全部结点，然后按照同样的次序访问处于第二层的结点，再访问第三层…，最后访问最下层的结点。

### 5.5堆和优先权队列

#### 5.5.1 堆

**堆的定义和存储表示**

一个大小为 n 的堆是一棵包含n个结点的<mark>完全二叉树</mark>， 其根结点称为堆顶，根据堆中亲子结点的大小关系，堆可以分为如下两类。

1. 最小堆∶如果树中每个结点的元素都小于或等于其孩子结点的元素，则该堆为最小堆。在最小堆中，堆顶存储的元素是整棵树中最小

2. 最大堆∶如果树中每个结点的元素都大于或等于其孩子结点的元素，则该堆为最大堆。在最大堆中，推顶存储的元素是整棵树中最大

**堆的存储表示**

根据堆的定义可知,堆的逻辑结构是树形结构,并且是特殊的树形结构,即完全二叉树,所以堆于堆而言,我们存储的时候同样可以采用顺序存储的表示方法.

我们不妨假设一个包含n个元素的堆，其对应的顺序存储表示为顺序表（ko，k……k，1），ki为顺序表中的第i个元素。

最小堆和最大堆的条件要求如下∶当且仅当满足 ki≤k2i+1 且 ki≤k2i+2（i=0，1……（n-2）/2)时，该序列为最小堆;当前仅当满足ki≥k2i+1时且ki≥k2i+2。（i=0.1……（n-2）/2)小时，该序列为最大堆。

![2022-11-27-14-55-37-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011717577.png)

**建堆运算**

*目的是：*

1. 对一个任意排列的元素序列执行若干调整，使得该元素序列满足最小堆（或最大堆）要求。

*特性：*

1. 在一棵完全二叉树中，由于所有的叶结点没有孩子，这些叶结点自然是满足最小堆的要求的，无须调整——*因为对于堆来说他的特点就是孩子总大于或总小于其双亲节点，叶子节点没有孩子，所以总是满足要求的*

2. 建堆运算中的结点（元素）调整操作应从最后一个非叶结点也是最后一个叶结点的双亲结点开始，即位置为（n-2）/2的元素、重复执行调整操作，直到下标为0的元素完成调整，整个建堆运算结束。

对完全二叉树中的非叶结点，需要执行面向建堆的向下调整运算 AdjustDown，从而使得每一个非叶结点在完成调整之后，都能够满足最小堆要求

> 向下调整和建堆运算的代码

<mark>重点分析</mark>

1. 建堆操作实际上就是在一个数组中进行的操作

2. 我们从i=（n-2）/2的位置开始操作，这个位置是最后一个叶节点的双亲，此后我们让每轮i后退一格

3. 本质上是数组中元素的不断的位置交换，唯一的区别是我们要对这个数组下标的位置掌握的很清楚

4. 每次调整并不一定是一次就能调整好的，因为可能上一次调整的结果会影响下一次的改变，所以我们的调整本省也是一个循环

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#define MAXSIZE 10

typedef int ElemType;
//这个堆是完全二叉树它的存储直接是一个数组
void adjustdown(ElemType heap[],int current,int border)
{
    int p=current;
    int minchild;
    ElemType temp;
    while(2*p<=border)  //若p不是叶节点则执行调整
    {
        //2*p+2<=border,判断有没有右节点，有的话就是成立的
        //判断有没有右节点，并且左节点大于右节点的时候
        if ((2*p+2<=border)&&(heap[2*p+1]>heap[2*p+2]))
        {
            /* code */
            minchild=2*p+2;
        }else minchild=2*p+1;           //不满足上面的无论有没有右子树都是取左子树了

        if (heap[p]<=heap[minchild])
            break;              //此时就满足最小堆定义了
        else {
            temp=heap[minchild];
            heap[minchild]=heap[p];
            heap[p]=temp;
            //此时任务还没有结束，我们还要继续调整
            p=minchild;
        }

    }
}
void creatheap(ElemType heap[],int n)
{
    int i;
    //从最后一个非叶子节点开始，也就是(n-2)/2
    for(i=(n-2)/2;i>-1;i--)
    {
        adjustdown(heap,i,n-1);     //当前要调整的位置，下边界的位置
        //共有n个节点，所以下边界最远到达n-1；
    }
}
int main()
{
    srand(time(NULL));
    int i=0;
    ElemType dui[MAXSIZE]={0};
    for(i=0;i<MAXSIZE;i++)
    {
        dui[i]=rand()%100+1;
    }
    for(i=0;i<MAXSIZE;i++)
    {
        printf("%d ",dui[i]);
    }
    printf("\n");
    //对树中的元素进行赋值
    creatheap(dui,MAXSIZE);
    for(i=0;i<MAXSIZE;i++)
    {
        printf("%d ",dui[i]);
    }
    printf("\n");
    return 0;

}
```

> 向上调整建堆其实和向下的差不多

大概就是将第一个破坏堆序性的元素，让其于父节点进行交换即可

#### 5.5.2 优先权队列

**优先权队列是利用堆来实现功能的一种数据结构，主要包括以下两种功能**

1. 根据最小堆的定义，堆顶元素是堆中具有最小值的元素，在最小堆的顺序存储结构中，堆顶元素处于顺序表的第一个元素位置。因此，从优先权队列中删除最高优先级的元素（即堆顶元素）的操作是容易实现的，只需取出和删除堆顶元素即可。

2. 删除堆项元素后，必须将堆中剩余元素重新调整成堆。同样，当有新元素插入队列时，也必须重新调整，使之成为最小堆。

**大概总结为删除，建堆，删除，建堆……**

> 算法

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#define MAXSIZE 10

typedef int ElemType;
typedef struct priorityQueue{
    ElemType*elements;  //存放数据元素
    int n; 
    int maxSize;
} priorityQueue;
//创建一个优先权队列
void creatPQ(priorityQueue *PQ,int msize)
{
    PQ->maxSize=mSize;
    PQ->n=0;
    PQ->elements=(ElemType*)malloc(mSize*sizeof(ElemType);
}
//销毁一个优先权队列，释放其占用的内存空间
void Destroy(PriorityQueue *PQ)
{
    free(PQ->elements);     //释放指针空间
    PQ->n=0;
    PQ->maxSize=0;
}
//判断优先权队列是否为空
bool IsEmpty(PriorityQueue *PQ)
{
    if(PQ->n==0)        //队列空了
        return true; 
    else
        return false;
}
//判断优先权队列是否已满
bool IsFull(PriorityQueue *PQ)
{
    if(PQ->n==PQ->maxSize)      //当前的元素等于最大存储的数量了
        return true;
    else
        return false;
}
//获取当前优先权队列中元素的数量
int Size(PriorityQueue *PQ)
{
    return PQ->n;
}
//在优先权队列中加入一个元素
void Append(PriorityQueue *PQ,ElemType x)
{
    if(IsFull(PQ))
        return;
    PQ->elements [PQ->n]=x; //在队列的最上面加入一个x
    PQ->n++;
    AdjustUp (PQ->elements,PQ->n-1);    //然后重新调整堆
}
//取出优先级最高的元素，利用参数x返回，并在优先权队列中删除该元素
void Serve(PriorityQueue *PQ,ElemType *x)
{
    if(IsEmpty(PQ))
        return;
    *x=PQ->elements [0];
    PQ->n--;
    PQ->elements[0]=PQ->elements[PQ->n];
    AdjustDown(PQ->elements,0,PQ->n-1);     //重新建立堆
}
void AdjustUp(ElemType heap[],int current)
{
    int p=current; 
    ElemType temp;
    while (p>0)
    {
        if(heap[p]<heap[(p-1)/2])//若p指向的元素小于其双亲结点，则与双亲结点交换
        {
            temp=heap[p]; heap[p]=heap[ (p-1)/2];heap[(p-1)/2]=temp;
            p=(p-1)/2; //将p向上移动至当前考查元素的双亲结点位置
        }
        else//若p指向的元素不小于其双亲结点，则调整完毕
            break;
    }
}

void adjustdown(ElemType heap[],int current,int border)
{
    int p=current;
    int minchild;
    ElemType temp;
    while(2*p<=border)  //若p不是叶节点则执行调整
    {
        //2*p+2<=border,判断有没有右节点，有的话就是成立的
        //判断有没有右节点，并且左节点大于右节点的时候
        if ((2*p+2<=border)&&(heap[2*p+1]>heap[2*p+2]))
        {
            /* code */
            minchild=2*p+2;
        }else minchild=2*p+1;           //不满足上面的无论有没有右子树都是取左子树了

        if (heap[p]<=heap[minchild])
            break;              //此时就满足最小堆定义了
        else {
            temp=heap[minchild];
            heap[minchild]=heap[p];
            heap[p]=temp;
            //此时任务还没有结束，我们还要继续调整
            p=minchi
```

### 5.6 哈夫曼树和哈夫曼编码

文本处理是现代信息技术的重要研究领域之一。文本一般由若干字符（字母、数字、符号等）构成，并以某种编码形式存储在计算机中。每个字符的编码可以是等长的，也可以是不等长的。

我们常用的GB2312编码和 ASCI 码等都是等长编码。

为了提高文本存储、处理和传输的

效率，在一些应用场合，如数据通信等，常采用不等长编码，通过对常用字符采用较短编码表示，缩减整个文本的编码长度。

哈夫曼编码就是这样的一种不等长的编码

#### 5.6.1 树的路径长度

树中结点的路径长度是指从树根到该结点的路径所包含的边的数量

***内路径长度***

除叶结点外，从树根到树中其他所有结点的路径长度之和。

每一个节点都有一个路径长度，在同一个路径上的节点，长度是独立计算的。

***外路径长度***

从树根到树中所有叶结点的路径长度之和。

![2022-11-27-17-06-28-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011718322.png)

***扩充二叉树***

设I和E分别是一棵扩充二叉树的内路径长度和外路径长度，n是该扩充二叉树中非叶结点的数量，则有∶

                                                    E=I+2n

***加权路径长度***

叶结点的加权路径长度∶若树中的叶结点带权，则叶结点的加权路径长度是从树根到该叶结点的路径长度与该叶结点的权值的乘积。

树中的所有叶节点的加权路径长度之和，记为WPL

![2022-11-27-17-14-13-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011718277.png)

#### 5.6.2 哈夫曼树和哈夫曼算法

给定一组权值构成的集合，并以此作为叶结点的权值，我们可以构造多棵扩充二叉树，它们通常具有不同的加权路径长度。

其中，具有最小加权路径长度的扩充二叉树，可用于构造压缩率更高的不等长编码

我们将哈夫曼算法构造的扩充二叉树称为哈夫曼编码树或哈夫曼树。一般而言，在使用一组权值作为叶结点权值构造扩充二叉树时，权值大的叶结点离根越近，所构造的扩充二叉树的加权路径长度越小。这就是哈夫曼算法的基本思想.

> 哈夫曼算法的步骤分析

1. 先用给定的n个权值的集合{w1，w2…，wn}生成一个包含n棵二叉树的森林F={T1，T2，T3……}其中每一刻二叉树Ti只有一个节点，这个节点就是权值为wi的节点——总的来说就是根据权值构建不同的独立的树

2. 其中每一刻棵二叉树只有一个节点，即权值为Wi的根节点

3. 从构建的子树中找出权值最小的两棵二叉树，设为T1和T2，然后对其进行合并，生成新的二叉树，一般将权值较小的设为左子树。新树的根节点是T1和T2的权值之和，然后将这个新生成的二叉树继续与其他的进行比较

4. 到最后二叉树只剩了一棵，那么这就是我们最终要得到的二叉树

> 哈夫曼的结构体

![2022-11-27-17-26-02-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/2022-11-27-17-26-02-image.png)

<mark>上述图片中提出了一个问题，即为什么数据与为2*n-1</mark>

因为叶子节点有n个，根据二叉树的性质，整棵树的节点数为2*n-1个

1. 数组huffTree初始化，所有的元素节点的双亲，左右孩子节点都置为1：

2. 数组huffTree的前n个元素的权值置给定值w[n];

3. 进行n-1次合并

4. 在二叉树集合中选取两个权值最小的根结点，其下标分别为i1和i2将二叉树合并为一棵新的二叉树k;

> 哈夫曼的算法分析

函数原型为

```c
BinaryTree CreateHFMTree(int w[],int m);
```

其中，wD为输入权值集合的数组，m表示输入的权值的数量。函数返回的二叉树即为最终生成的哈夫曼树。

我们在这个函数中还需要构建树的算法即maketree算法

还需要使用优先权队列，以根节点存储的权值优先级存储二叉树，当获取根节点权值最小的两棵二叉树的时候，只需要执行两次优先权队列的serve算法即可

> 哈夫曼算法的伪代码

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#define QUANZHI 7
#define PQMAXSIZE 7

typedef int ElemType;
typedef struct btnode
{
    ElemType element;
    struct btnode* lchild;
    struct btnode* rchild;
}btnode;
//二叉树的结构体
typedef struct binarytree
{
    btnode* root;
}binarytree;
typedef struct priorityQueue {
    binarytree* elements;  //存放数据元素
    int n;
    int maxSize;
} priorityQueue;
//创造一个新的空二叉树bt
void creat(binarytree * bt)
{
    bt->root = NULL;              //对于一个树来说，我们只需要创造一个根节点即可
}

//创建一个优先权队列
void creatPQ(priorityQueue* PQ, int msize)
{
    PQ->maxSize = msize;
    PQ->n = 0;
    PQ->elements = (binarytree*)malloc(msize * sizeof(binarytree));
}

//向上调整建堆
void AdjustUp(binarytree heap[], int current)
{
    int p = current;
    binarytree temp;
    while (p > 0)
    {
        if (heap[p].root->element < heap[(p - 1) / 2].root->element)//若p指向的元素小于其双亲结点，则与双亲结点交换
        {
            temp = heap[p]; 
            heap[p] = heap[(p - 1) / 2]; 
            heap[(p - 1) / 2] = temp;        //结点的交换
            p = (p - 1) / 2; //将p向上移动至当前考查元素的双亲结点位置
        }
        else//若p指向的元素不小于其双亲结点，则调整完毕
            break;
    }
}
void adjustdown(binarytree heap[], int current, int border)
{
    int p = current;
    int minchild;
    binarytree temp;
    while (2 * p <= border)  //若p不是叶节点则执行调整
    {
        //2*p+2<=border,判断有没有右节点，有的话就是成立的
        //判断有没有右节点，并且左节点大于右节点的时候
        if ((2 * p + 2 <= border) && (heap[2 * p + 1].root->element > heap[2 * p + 2].root->element))
        {
            /* code */
            minchild = 2 * p + 2;
        }
        else minchild = 2 * p + 1;           //不满足上面的无论有没有右子树都是取左子树了

        if (heap[p].root->element <= heap[minchild].root->element)
            break;              //此时就满足最小堆定义了
        else {
            //进行节点的交换
            temp = heap[minchild];
            heap[minchild] = heap[p];
            heap[p] = temp;
            //此时任务还没有结束，我们还要继续调整
            p = minchild;
        }

    }
}
//判断优先权队列是否已满
bool IsFull(priorityQueue* PQ)
{
    if (PQ->n == PQ->maxSize)      //当前的元素等于最大存储的数量了
        return true;
    else
        return false;
}
//判断优先权队列是否为空
bool IsEmpty(priorityQueue* PQ)
{
    if (PQ->n == 0)        //队列空了
        return true;
    else
        return false;
}
//在队列上面加入一个元素
void Append(priorityQueue* PQ, binarytree* x)
{
    if (IsFull(PQ))
        return;
    PQ->elements[PQ->n] = *x; //在队列的中加入一个x，我们是插入到最后一个然后重新调整
    PQ->n++;
    AdjustUp(PQ->elements, PQ->n - 1);    //然后重新调整堆
}
//创造树的节点
btnode* newnode(ElemType x, btnode* ln, btnode* rn)
{
    btnode* p = (btnode*)malloc(sizeof(btnode));      //新建一个节点，以便于我们能够返回
    p->element = x;
    p->lchild = ln;
    p->rchild = rn;
    return p;
}
//生成树
void maketree(binarytree* bt, ElemType e, binarytree* left, binarytree* right)
{
    if (bt->root || left == right)
        return;
    bt->root = newnode(e, left->root, right->root);
    left->root = right->root = NULL;                //left和right的节点都连接到bt中了，为了重复使用，我们可以对其进行归零
}

void Serve(priorityQueue* PQ, binarytree* x)
{
    if (IsEmpty(PQ))
        return;
    *x = PQ->elements[0];
    PQ->n--;
    PQ->elements[0] = PQ->elements[PQ->n];    //优先权队列的调整，让第一个被删除的元素和最后一个元素交换，然后重新建堆
    adjustdown(PQ->elements, 0, PQ->n - 1);     //重新建立堆
}
//构建哈夫曼树
binarytree CreateHEMTree(int w[], int m)
{
    priorityQueue PQ;   //定义优先权队列 PQ，用于存放二叉树根结点指针
    binarytree x, y, z; //x，y，z为二又树变量 BinaryTree x,y,z;
    creat(&x);
    creat(&y);
    creat(&z);
    creatPQ(&PQ, m);  //初始化优先权队列 PQ，设优先权值存在根结点数据域
    for (int i = 0; i < m; i++)
    {
        maketree(&x, w[i], &y, &z);          //利用权值构建n棵子树
        Append(&PQ, &x);
        creat(&x);
    }
    while (PQ.n > 1)
    {
        Serve(&PQ, &x);//从 PQ中取出根结点权值最小的二叉树，存入x
        Serve(&PQ, &y);//从 EQ中取出根结点权值次小的二叉树，存入y
        //合并x(和y，作为新二叉树z的左右子树，z的优先权值等于x和y的优先权值之和
        if (x.root->element < y.root->element)//设置左子树根结点权值小于右子树
            maketree(&z, x.root->element + y.root->element, &x, &y);
        else
            maketree(&z, x.root->element + y.root->element, &y, &x);
        Append(&PQ, &z); //将合并生成的新二叉树z 插入优先权队列
        creat(&z);
    }
    Serve(&PQ, &x); //获取优先权队列中唯一的二叉树，存入x，该二叉树即为哈夫曼树
    return x;
}
//树的遍历
//先序遍历算法的主算法
void preorder(btnode* t)
{
    if (!t)
        return;
    printf("%d  ", t->element);
    preorder(t->lchild);        //遍历左子树
    preorder(t->rchild);        //遍历右子树
    return;
}
//从根节点开始引入函数
void preordermain(binarytree* bt)
{
    preorder(bt->root);
}
int main()
{
    int w[QUANZHI] = {9,5,2,3,11,7,8 };//构建一个权值序列
    binarytree x;
    x = CreateHEMTree(w, PQMAXSIZE);
    preordermain(&x);
    return 0;
}
```

> 哈夫曼编码

![2022-11-27-17-57-05-image](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301011719527.png)

## 集合和搜索
### 6.1.1集合的基本概念
常见的四种基本存储结构
1. 集合结构，元素无关系
2. 线性结构
3. 树形结构
4. 图形结构

> 集合的种类

1. 多重集 每个元素可以出现一次或者多次
2. 动态集 元素可以随时离开,也可以随时加入
3. 有序集 元素可以出现一次或者多次,但是元素出现的次序是重要的,(1\2\3)和(3\2\1)是不一样的

>关键字

可以用来标识一个数据元素,若其可以唯一标识一个数据元素,则称改关键字位主关键字,反之则称为次关键字

> 搜索

1. 静态搜索 仅搜索,不改动数据
2. 动态搜索 搜索后改动数据,比如说数据的插入和删除
3. 内搜索   元素在内存内
4. 外搜索   元素在内存外
5. 搜索长度  给定值在集合中的位置,平均搜索长度可用于衡量算法的时间效率

### 6.1.3 集合的表示

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#define Maxsize 20
#define WuQiong 2000
typedef int ElemType;
typedef struct List{
    int n;
    int maxsize;
    ElemType *element;
}List;

//初始化集合
bool init(List *l,int size)
{
    l->maxsize=Maxsize;
    l->n=size;
    l->element=(ElemType *)malloc(sizeof(ElemType)*Maxsize);
    if(!l->element)
    {
        return false;
    }
    else
    {
        srand(time(NULL));
        for (int i = 0; i < l->n; i++)
        {
            l->element[i]=rand()%100+1;
        }
        return true;
    }
        
}
//撤销运算
bool destroy(List *l)
{
    if(l->element)
    {
        free(l->element);
        l->maxsize=0;
        l->n=0;
        return true;
    }
    else
        return false;
}
//判断集合是否为空
bool isempty(List *l)
{
    if(l->n==0)
        return true;
    else
        return false;
}
//获取集合的大小
int getsize(List *l)
{
    return l->n;
}
//输出集合
void output(List *l)
{
    for(int i=0;i<l->n;i++)
    {
        printf("%d ",l->element[i]);
    }
    printf("\n");
}
//获取第i个元素
ElemType getelem(List *l,int i)
{
    if(i<0||i>=l->n)
    {
        printf("该元素不存在\n");
        return 0;
    }
    else
        return l->element[i];
}
//搜索集合中与x相等的元素
//无序表的顺序搜索
int search(List *l,ElemType x)
{
     int i;
     for(i=0;i<l->n;i++)
     {
        if(l->element[i]==x)
        {
            return i;
        }
     }
     return -1;
}
//排序
void sort(List *h)
{
    
    int temp=0,k=0,i=0;
    for(int j=0;j<h->n;j++)
    {
        int min=h->element[j];
        k=j;
        for(i=j+1;i<h->n;i++)
        {
            if(min>h->element[i])
            {
                min=h->element[i];
                k=i;
            }
        }
        temp=h->element[k];
        h->element[k]=h->element[j];
        h->element[j]=temp;
    }
    return;
}
```

### 6.2 顺序搜索

> 无序表的顺序搜索

基本思路是,从表的一段开始,按顺序扫描表,逐个检查每个数据元素的关键字,直至找到表中关键字值等于给定值的元素

```c
//无序表的顺序搜索
int search(List *l,ElemType x)
{
     int i;
     for(i=0;i<l->n;i++)
     {
        if(l->element[i]==x)
        {
            return i;
        }
     }
     return -1;
}
```

> 有序表的顺序搜索

基本思路是对顺序表先排序,然后在搜索,关键点在于这个终止条件有点特殊,它的终止条件并不是顺序表遍历完,而是顺序表此时便利的元素大于关键字的时候终止

为了防止程序遍历到最后越界还没终止,我们可以定义一个哨兵,哨兵是宏定义无穷大,记住哨兵的添加,是直接添加的,顺序表的长度是没有改变的,即只改变了顺序表的最后一位元素,然后让其参加比较

```c
//排序
void sort(List *h)
{
    
    int temp=0,k=0,i=0;
    for(int j=0;j<h->n;j++)
    {
        int min=h->element[j];
        k=j;
        for(i=j+1;i<h->n;i++)
        {
            if(min>h->element[i])
            {
                min=h->element[i];
                k=i;
            }
        }
        temp=h->element[k];
        h->element[k]=h->element[j];
        h->element[j]=temp;
    }
    return;
}
//顺序表的搜索
int sequence_search(List *l,ElemType x)
{
    int i;
    //加入哨兵
    l->element[l->n]=WuQiong;
    //l->n++;  添加哨兵,但是这个哨兵是不算在集合的大小里的,只用来比较这个
    for(i=0;x>=l->element[i];i++)
    {
        if(l->element[i]==x)
        {
            return i;
        }
    }
    return -1;
}
```

>  时间复杂度分析

![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301020856826.png)

![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202301020855924.png)

### 6.3 对半搜索

这是一种效率更高的搜索方法,要求线性表是有序表,并采用顺序存储结构

> 原理

每次都让被搜索的x与区间的中点进行比较，区间的左右值为low和high，然后每次都让x与l->element[(low+high)/2]比较，然后如果小于则hgih=(low+high)/2-1如果大于low=(low+high)/2+1

> 代码

```c
//对半搜索的递归
int half_recursion_search(List *l,ElemType x,int low ,int high)
{
    int m=(low+high)/2;
    if(l->element[m]==x)
        return m;
    else if(l->element[m]>x)
    {
        return half_recursion_search(l,x,low,m-1);
    } else return half_recursion_search(l,x,m+1,high);
    return -1;
}
```

```c
//对半搜索的迭代算法
int half_Iteration_search(List *l,ElemType x)
{
    int m,low=0,high=l->n-1;
    while (low<=high)
    {
        m=(low+high)/2;
        if(l->element[m]==x) return m;
        else if(l->element[m]>x) high=m-1;
        else low=m+1;
    }
    return -1;
} 
```

> 递归和迭代的区别

迭代是一种为了逼近所需目标或者结果，不断用变量的旧值递推新值的过程，其实就是，用递归的下一层的返回值作为迭代下层循环的开始值

迭代与循环，迭代和递归一样，也是循环的一种
迭代，当前保存的结果作为下一次循环计算的初始值，迭代使用计数器来结束循环——它就是个循环要有个终止条件

递归是有去有回，因为存在着终止条件，就比如说你打开一扇门，但还有一扇门，不断打开，最终会碰到，，一面墙返回

循环时有去无回，但可以设置终止条件，你打开门还有门，不断打开，不断有门，无终点

### 6.3.2二叉判定树

描述对半搜索过程的二叉树称为对半搜索的二叉判定树,此二叉树的内部节点用圆点表示

## 搜索树

### 7.1 二叉搜索树

用树形结构表示集合，可以有效的提高搜索效率，树结构比线性结构更适合表示动态集

**二叉搜索树的定义**
（1）二叉树中任意两个结点的关键字值不相同;所以这里也是二叉搜索树的一个缺陷就是其不能处理有相同数据的情况。
（2）若左子树不空，则左子树上所有结点的关键字值均小于根结点的关键字值;
（3）若右子树不空，则右子树上所有结点的关键字值均大于根结点的关键字值;
（4）左、右子树也分别是二叉搜索树。

> 性质1

若以中序遍历一棵二叉搜索树，将得到一个以关键字值递增排列的有序序列.所以，二叉搜索树也称二叉排序树。

```c
typedef int KeyType;
typedef struct Entry
{
	KeyType Key;//关键字
	//我们还可以添加其他的数据
}Entry;
typedef struct bstnode
{
	Entry element;
	struct bstnode* lchild, * rchild;
}bstnode;

```

#### 7.2 二叉搜索树的搜索

（1）若二叉搜索树为空，则搜索失败，返回空指针。
（2）若二叉搜索树不为空，则将指定关键字值k与根结点元素的关键字值比较;
①若k等于该关键字值，则搜索成功，返回根结点地址;
②若k小于该关键字值，则以同样的方法搜索左子树，而不必搜索右子树;
③若k大于该关键字值，则以同样的方法搜索右子树、而不必搜索左子树。

>搜索二叉树的递归搜索代码

```c
// 二叉搜索的递归搜索
//我们的返回值是树的节点
bstree searchTree(bstree T, KeyType k)
{
	//搜先先判断二叉搜索树是否为空
	if (!T)
		return NULL;
	if (T->element.Key == k) {
		return T;
	}
	else if (T->element.Key <= k) {
		return searchTree(T->rchild, k);
	}
	else {
		return searchTree(T->lchild, k);
	}
}
```

> 搜索二叉树的迭代搜索代码

```c
bstree searchTreeLiteration(bstree T, KeyType k)
{
	while (T)
	{
		if (T->element.Key == k) {
			return T;
		}
		else if (T->element.Key <= k) {
			T = T->rchild;
		}
		else {
			T = T->lchild;
		}
	}
	//这里就不用加入一个判断语句了，应为此时的T已经执行完了判断语句
	return NULL;
}
```

#### 7.3 二叉搜索树的插入
我们分为三步走
1. 先判断这个元素的关键字与现有元素的关键字值都不同,为此先对二叉搜索树进行搜索,如果搜索失败,则将元素插入到搜索结束处.

二叉搜索树的插入算法

```
// 二叉搜索树插入的迭代算法
bool insertTree(bstree T, Entry e)
{
	bstree p = T, q, r;
	KeyType k = e.Key;
	while (p)
	{
		q = p;//保留双亲节点
		if (p->element.Key == k) {
			printf("Duplicate");
		}
		else if (p->element.Key <= k) {
			p = p->rchild;
		}
		else {
			p = p->lchild;
		}
	}
	r = (bstnode*)malloc(sizeof(bstnode));
	r->element = e;
	r->lchild = NULL;
	r->rchild = NULL;
	if (!T)
		T = r;
	else if(k<q->element.Key)
	{
		q->lchild = r;
	}
	else
	{
		q->rchild = r;
	}
	return true;
}
```

#### 7.4 二叉搜索树的删除
叶结点的删除很简单。只需要将其双亲节点的左右子树的某一个置为NULL即可,并释放该节点

删除仅有一棵非空子树的非叶结点也很简单,在删除目标结点后、今其唯一的非空子树取代其原来的位置即可
**删除25,就是让28取代它,因为28是它唯一的子节点**
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202302222009080.png)

而在删除有两棵非空子树的非叶结点时，可首先用其左子树中最大元素所在结点或其右子树中最小元素所在结点替代该结点。然后，将替代结点从其子树中删除。
**删除关键字值为 30 的结点**
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202302222015196.png)

这种删除操作的具体实现步骤为:
首先搜索待删除元素所在的结点，记为结点p.并记录p的双亲结点 q。如果不存在待删除的元素，应返回NotPresent。如果存在待删除的元素，则删除结点p的操作可分下面两种情况讨论。
1. 若结点p有两棵非空子树，这时需搜索p的中序遍历次序下的直接后继（或直接前驱）结点，设为结点s。然后将s的值复制到待删除结点p中，称为替代。因为结点s最多只有一棵非空子树，这样一来，问题便转化为"被删除的结点最多只有一棵非空子树"的问题。
2. 当结点p只有一棵非空子树或p是叶结点时，若p->LChild非空，则由p->LChild取代p，否则由p->RChild取代p。事实上，若p是叶结点，将以NULL取代p
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202302222018482.png)
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202302222018627.png)
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202302222018770.png)


#### 7.5 二叉搜索树的高度
棵有 n个元素的二叉搜索树的高度最大面以为D 例如，从空树开始，依次将一组关键字{20，30，40，50，60，70}插入二叉搜索树，得到的树的高度为6，称为"退化"树形
对这样的树进行搜索、插入和删除操作所需的时间复杂度O(n）。
但是当进行随机插入和删除时，二叉搜索树的平均高度为 O(logn)。
因此，对二叉搜索树的搜索、插入和删除操作的平均时间复杂度为O（logn）。

### 7.2 二叉平衡树
#### 7.2.1 二叉平衡树的定义
二叉平衡树是带有平衡条件的二叉搜索树，有一个别名叫做AVL树,它或者是一个空的二叉搜索树,或者是具有下列性质的二叉搜索树
1. 其根的左、右子树高度之差的绝对值不超过1
2. 其根的左、右子树都是二叉平衡树
AVL 树实际上是一棵平衡的二叉搜索树，兼具排序性和平衡性。
1. 其中排序性体现在二叉平衡树中任意一个结点的关键字值大于其左子树（如其不空）上所有结点的关键字值，同时小于其右子树（如其不空）上所有结点的关键字值。
2. 平衡性则体现在二叉平衡树中任意一个结点的左、右子树高度之差的绝对值不超过1

若将二叉树上结点的平衡因子定义为该结点的左子树高度减去右子树高度，则二叉平衡树上（所有结点的平衡因子只可能是-1、0或1。**只要二叉搜索树上有一个结点的平衡因子的绝对值大于1，该树就不是二叉平衡树。**

>其与二叉搜索树的区别

二叉平衡树同时也是一个二叉搜索树,它的搜索可以按照普通二叉树的搜索方式进行
它的插入也可以按照普通而擦函数的插入方式进行,但是可能插入后平衡性会遭到破坏,所以我们要进行调整平衡性

#### 7.2.2 二叉平衡树的平衡调整方法
二叉平衡树的平衡调整方法通常有两种,一种是单旋转方法,另一种是双旋转方法

> 单旋转法

如果插入的节点破坏了平衡因子,那么只有从新结点到根结点路径上的结点的平衡因子可能被改变，因为只有这些结点的子树可能发生变化。
事实上，当新元素的插入破坏了二叉平衡树的平衡条件导致需要重新平衡时，我们只需找到新元素插入后由新结点回溯至根结点路径上第一个出现的非平衡结点（此处所说的非平衡结点即为平衡因子绝对值大于1的结点），也就是离新插入结点最近且平衡因子绝对值超过1的那个组先结占不妨将其标记为s，我们将以结点s为根结点的子树称为需要重新平衡的最小子树。
