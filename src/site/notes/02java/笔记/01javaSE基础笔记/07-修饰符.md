---
{"dg-publish":true,"permalink":"/02java//01java-se/07/","dgPassFrontmatter":true}
---

# 修饰符
完整的教程参考下面的链接
[菜鸟教程-修饰符](https://www.runoob.com/java/java-modifier-types.html)
下面是我总结的比较精简的内容
常见的修饰符有权限修饰符和非权限修饰符
## 权限修饰符
权限修饰符就是我们所熟知的 private，public，protect，default（什么都不写，默认），我们通过这个权限修饰符来限制
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202309131627398.png)
总之：
**权限修饰符就是用来管理这个类中的变量和方法的访问权限的，具体的访问权限设置参考上面的表**
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202304161034210.png)

![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202304161035045.png)
## 非权限修饰符
常用的是 final，static, abstract
### Static
#### 静态变量
> 举例

我们定义了一个学生类, 然后通过这个类创建多个学生对象, 每个学生对象有一个属性是年龄, 姓名, 性别和老师,
这些学生对象有一些属性是各不相同的, 但是也有一个属性是公有的, 就是这个老师的属性, 这些学生对应的老师是相同的,
我们如果要给这些学生对象进行赋值的话, 那么久太麻烦了, 所以我们引入 static 关键字, 通过这个关键字我们可以实现一个变量被多个对象所共有, 同时我们的这个 static 定义的变量还可以直接通过类名进行访问

比如我们定义了一个 student 类, 然后里面的 tearchname 是 static 类型的, 然后我们就可以直接
Student. Teachname 进行访问变量

Static 修饰符, 是修饰这个变量属于这个类, 而不是属于对象
**我们通过这个类名来访问这个 static 变量，而不是通过变量名**
**static 的关键特点**
1. 其被改类所有对象共享
2. 可以通过类名调用, 我们推荐这种
3. 也可以被对象名调用

#### 内存分析

这个 static 定义的关键字的对象存放到堆区的一个静态空间中,

![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202304111456616.png)

#### 静态方法
被 static 修饰的成员变量, 叫做静态变量
被 static 修饰的成员方法, 叫做静态方法
**特点**
1. 多用于测试类和工具类中
2. Javabean 类中很少会用

**调用方式**
1. 类名调用
2. 对象名调用

#### 三种不同的类的区别
1. JavaBean 是用来描述一类事物的类, 比如 student ,user
2. 测试类用来检查其他类是否书写正确, 带有 main 方法的类, 是程序的入口
3. 工具类, 不是用来描述一些事物的, 而是帮我们做一些事情的类

#### 工具类
1. 类名要见名知意
2. 私有化构造方法,**因为这个工具类, 不是用来描述一些事物的, 你创建这个工具类的对象, 没有意义, 所以我们要私有化, 防止外界调用**
3. 简单来说这个工具类就是我们封装的一系列的函数, 我们可以直接进行使用, 例如这个. Length 这个函数

#### Static 的注意事项
1. 静态方法只能访问静态变量和静态方法
2. 非静态方法可以访问静态变量或者静态方法, 也可以访问非静态的成员变量和非静态的成员方法
3. 静态方法中是没有 this 关键字的

1. 静态方法中, 只能访问静态, 非静态是变化的, 静态是不能访问非静态的, 因为它不知道要访问的是哪一个对象的变量
2. 非静态方法可以访问所有
3. 静态方法没有 this 关键字, 因为 this 指向的是对象, 但是静态方法指向的确实这个类,


Static 是用来声明静态变量的，无论一个类新建了多少份，但是静态变量有且只能有一份，比如说，学生类对象，每个学生都有一个老师如果我们每个学生类对象都新建一个老师对象的话，第一就是占用内存，第二就是有可能造成老师的数据错误，因此我们可以创建这个静态对象。
举例，例如下面的这个
```java
public class Students {
    private String name;
    private int age;
    private String sex;
    private static String teacherName;
}
```
### Final
Final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。
1. 如果用 final 修饰方法，表示方法是最终方法，不能被重写
2. 如果用 final 修饰类，表明该类是最终类，不能被继承
3. 如果用 final 修饰变量，叫做常量，只能被赋值一次

如果 final 修饰引用数据类型，记录的地址值不能发生改变，内部的属性值还是可以发生改变的。
比如说，对象类型，数组类型
**我们常常可以将这个 final 和 static 搭配使用，实现创建这个静态常量**
关于这个字符串的一些解释：
我们在学习字符串的时候知道字符串是不可以进行变化的，这也就是因为字符串的源代码中是 final 类型的。
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202309131637997.png)
常量
实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。
**常量的命名规范:**
1. 单个单词: 全部大写
2. 多个单词: 全部大写，单词之间用下划线隔开

**细节:**
1. Final 修饰的变量是基本类型: 那么变量存储的数据值不能发生改变。
2. Final 修饰的变量是引用类型: 那么变量存储的地址值不能发生改变，对象内部的可以改变。、

### abstract
abstract 用来构造抽象类和抽象方法
#### 抽象类
> 抽象类是必须要进行重写的,, 不能够直接创建对象, 我们可以采用多态的方法进行创建对象

对象代表什么, 就得封装对应的数据, 并提供相应的数据
当数据类型比较多的时候, 我们就会用到继承,
当子类的某个行为大致方向相同, 但是具体不同的话, 我们一般是在父类中随便写一个, 然后再子类中用多态进行重写
#### 抽象类的定义格式
定义的时候我们就是直接再 class 前面加入 abstract
#### 抽象方法和抽象类
抽象方法: 将共性的行为（方法）抽取到父类之后。
	由于每一个子类执行的内容是不一样，所以，在父类中不能确定具体的方法体。该方法就可以定义为抽象方法。
抽象类: 如果一个类中存在抽象方法，那么该类就必须声明为抽象类
**注意事项**
1. 抽象类不能实例化, 就是不能创建对象
2. 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类-**否则系统会报错的**
3. 可以有构造方法, 当创建子类对象的时候, 给属性进行赋值
4. 抽象类的子类, 写的时候会出现错误, 我们可以 alt 加回车有两个选择
	1. 要么重写抽象类中的所有抽象方法
	2. 要么是抽象类

当父类的某个方法写什么都不太合适的时候我们这个时候就将其转化为抽象方法.
> 格式修饰符 +abstract + 返回值类型 +函数名 ( ){ }

强制你这样命名, 防止格式不规范，构建抽象类之后，之后继承的子类的都要重写这个抽象方法，然后格式必须和父类的抽象方法一样。
```java
public abstract class Animal {
    //这是一个抽象类，作为所有动物比如说猫狗等的父类，
    //对于这种父类对象,其要继承给所有子类对象一个喜欢吃的方法,但是这个吃的方法怎么写都不合适,因为子类都有自己喜欢的,此时就要重写方法,这个时候就用到抽象类了
    private String name;
    private int age;
    public abstract void eat();
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return this.name;
    }
    public int getAge() {
        return this.age;
    }

}

```

```java
public class dog extends Animal {
    public dog(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        //重写方法的内容,此时狗最喜欢的是骨头
        System.out.println(getName()+"最喜欢吃骨头");
    }

    // 抽象类不能实例化
    // 抽象类不能创建对象
    // 抽象类中可以有抽象方法，也可以没有抽象方法
    // 抽象类中可以有普通方法，也可以没有普通方法
    // 抽象类中可以有静态方法，也可以没有静态方法
    // 抽象类中可以有构造方法，也可以没有构造方法
    // 抽象类中可以有属性，也可以没有属性

    
}
```
