---
{"dg-publish":true,"permalink":"/05leecode//216/","dgPassFrontmatter":true}
---



第一次运行结果，出现了三次一样的结果
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305171619097.png)
## 自己编写的程序

```java
package backtracking;  
  
import java.util.ArrayList;  
import java.util.LinkedList;  
import java.util.List;  
import java.util.Scanner;  
  
public class combineSum {  
    static int num = 0;  
    static LinkedList<Integer> path = new LinkedList<>();  
    static List<List<Integer>> result = new ArrayList<>();  
    public static void main(String[] args) {  
        int n;  
        int k;  
        Scanner input = new Scanner(System.in);  
        System.out.println("输入n,1 <= n <= 60");  
        n=input.nextInt();  
        System.out.println("输入k,2 <= k <= 9");  
        k=input.nextInt();  
  
        backTracking(1,n,k);  
        System.out.println(result);  
    }  
    public static void backTracking(int startIndex,int n,int k){  
        //问题来了，如何让这个num恢复原样呢，要有减法  
        if(path.size()==k){   //当和为n，并且长度是正确的时候才会添加路径，返回到上一步  
            //当size==3的时候必须要返回  
            if(num==n){  
                result.add(new ArrayList<>(path));  // 将路径添加进去  
            }  
            num-=startIndex-1;  //把它的上一个元素减掉  
            path.removeLast();  //移除最后一个元素  
            return;    //返回到上一步  
        }  
        for (int i= startIndex;i<=n&&i<=9;i++){  
            num+=i;  
            if(num<=n){  
                path.add(i);  
                backTracking(i+1,n,k);  
                //这里加入一个判断语句进行return  
            }else{  
                //因为当这个num<=n的时候这个path,add不执行,所以有时候这个path中是空的.  
                path.removeLast();  
                num = path.stream().mapToInt(Integer::intValue).sum();  
                //这里我的return是想让它返回到上上一步  
                return;  
            }  
        }  
  
        path.removeLast();  
        num = path.stream().mapToInt(Integer::intValue).sum();  
        //这里我的return是想让它返回到上上一步  
        return;  
    }  
}
```

## 分析问题
自己的代码敲写的时候总是无法通过这个所有的示例,归根到底就是自己太喜欢用if了,用if语句进行判断是个好事,但是对于这种算法题,我们如果是通过很多if来进行做出来的,肯定是不对的,因为我们无法考虑到所有的情况,因此我们要尽量找到这个的通解
```java
if(path.size()==k){   //当和为n，并且长度是正确的时候才会添加路径，返回到上一步  
	//当size==3的时候必须要返回  
	if(num==n){  
		result.add(new ArrayList<>(path));  // 将路径添加进去  
	}  
	num-=startIndex-1;  //把它的上一个元素减掉  
	path.removeLast();  //移除最后一个元素  
	return;    //返回到上一步  
}  
```

```java
num+=i;  
if(num<=n){  
	path.add(i);  
	backTracking(i+1,n,k);  
	//这里加入一个判断语句进行return  
}else{  
	//因为当这个num<=n的时候这个path,add不执行,所以有时候这个path中是空的.  
	path.removeLast();  
	num = path.stream().mapToInt(Integer::intValue).sum();  
	//这里我的return是想让它返回到上上一步  
	return;  
}  
```
这个题做的另一个问题就是我对这个递归树理解的还不是太透彻,其中的sum应该是每一条路径都有一个sum,因此这个sum应该是每一个路径都有的这个和,并且都不一样,自己做的时候竟然忽略了这个问题.把这个sum当做了一个全局变量


## 最后代码
```java
package backtracking;  
  
import java.util.ArrayList;  
import java.util.LinkedList;  
import java.util.List;  
import java.util.Scanner;  
  
public class combineSum {  
    static LinkedList<Integer> path = new LinkedList<>();  
    static List<List<Integer>> result = new ArrayList<>();  
    public static void main(String[] args) {  
        int n;  
        int k;  
        Scanner input = new Scanner(System.in);  
        System.out.println("输入n,1 <= n <= 60");  
        n=input.nextInt();  
        System.out.println("输入k,2 <= k <= 9");  
        k=input.nextInt();  
  
        backTracking(1,n,k,0);  
        System.out.println(result);  
    }  
    public static void backTracking(int startIndex,int n,int k,int sum){  
		//剪枝操作，我们通过这个操作，避免下面的没必要的代码进行执行
        if(sum>n){  
            return;  
        }  
        //终止条件  
        if(path.size()==k){   //当和为n，并且长度是正确的时候才会添加路径，返回到上一步  
            //当size==3的时候必须要返回  
            if(sum==n){  
                result.add(new ArrayList<>(path));  // 将路径添加进去  
            }  
            return;    //返回到上一步  
        }  
        for (int i= startIndex;i<=n&&i<=9;i++){  
            sum+=i;  
            path.add(i);  
            backTracking(i+1,n,k,sum);  
            sum-=i;  
            path.removeLast();  
        }  
    }  
}
```

