---
{"dg-publish":true,"permalink":"/05leecode//17/","dgPassFrontmatter":true}
---

## 分析
这个题目的组合和77题的组合是类似的，但是又不太一样，这个的组合是三个三个为一组的，而77题的组合是每一个都单独为一组


## 代码

刚开始自己利用了自己比较熟悉的方式进行实现了这个代码.利用了字符的集合的集合,以及数组题目要求是字符串集合,和字符串
```java
package backtracking;  
  
import java.util.ArrayList;  
  
public class 电话号码的字母组合 {  
    static ArrayList<Character> path = new ArrayList<>();  
    static ArrayList<ArrayList<Character>> result = new ArrayList<>();  
    static ArrayList<ArrayList<Character>> ch = new ArrayList<>();  
    public static void main(String[] args) {  
        ArrayList<Character> temp = new ArrayList<>(){};  
        char[] temp1 = new char[]{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};  
        for(int i=0;i<5;i++){  
            for(int j=0;j<3;j++){  
                temp.add(temp1[j+i*3]);  
            }  
            ch.add(new ArrayList<>(temp));  //添加进去  
            temp.clear();  
        }  
  
        for(int j=0;j<4;j++){  
            temp.add(temp1[j+5*3]);  
        }  
        ch.add(new ArrayList<>(temp));  //添加进去  
        temp.clear();  
  
        for(int j=0;j<3;j++){  
            temp.add(temp1[j+6*3]);  
        }  
        ch.add(new ArrayList<>(temp));  //添加进去  
        temp.clear();  
  
        for(int j=0;j<4;j++){  
            temp.add(temp1[j+7*3]);  
        }  
        ch.add(new ArrayList<>(temp));  //添加进去  
        temp.clear();  
  
  
        //现在这个ch是电话本了  
        int[] digit = new int[3];  
        digit[0]=0;  
        digit[1]=1;  
        digit[2]=4;  
        backTracking(0,digit);  
        System.out.println(result);  
  
    }  
    public static void backTracking(int button,int[] digit){  
        if(path.size()==digit.length){  
            result.add(new ArrayList<>(path));  
            return;  
        }  
        //没有这个会越界的
        if(button==digit.length){  
            return;  
        }  
        //两轮循环  
        for(int i=digit[button];button<digit.length;button++){  
            for(int j=0;j<3;j++){  
                path.add(ch.get(i).get(j));  //将这个按钮添加到这个路径中  
                //我们执行递归的时候要进行这个初始位置的判断  
                backTracking(button+1,digit);  
  
                //进行回溯  
                path.remove(path.size()-1);  //移除最后一个元素  
            }  
        }  
    }  
}
```

## 优化代码

这个优化代码解决了这个最开始的时候返回值的类型与要求的结果的不同的情况

```java
package backtracking;  
  
import java.util.ArrayList;  
import java.util.Collections;  
import java.util.List;  
import java.util.Scanner;  
  
public class 电话号码的字母组合优化 {  
    static ArrayList<Character> path = new ArrayList<>();  
    static List<String> list = new ArrayList<>();  
    static ArrayList<String> ch = new ArrayList<>();  
    public static void main(String[] args) {  
        ArrayList<Character> temp = new ArrayList<>(){};  
        //char[] temp1 = new char[]{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};  
        ch.add("");  
        ch.add("");  
        ch.add("abc");  
        ch.add("def");  
        ch.add("ghi");  
        ch.add("jkl");  
        ch.add("mno");  
        ch.add("pqrs");  
        ch.add("tuv");  
        ch.add("wxyz");  
  
  
        String s = new String();  
        Scanner input = new Scanner(System.in);  
        System.out.println("输入字符串");  
        s=input.next();  
        backTracking(0,s);  
        System.out.println(list);  
  
  
    }  
    public static void backTracking(int button,String s){  
        if(path.size()==s.length()){  
            StringBuilder sb = new StringBuilder();  
            for (Character c : path) {  
                sb.append(c);  
            }  
            list.add(sb.toString());  
            return;  
        }  
        //没有这个会卡顿的  
        if(button==s.length()){  
            return;  
        }  
        //两轮循环  
        for(int i=s.charAt(button)-48;button<s.length();button++){  
            for(int j=0;j<3;j++){  
                path.add(ch.get(i).charAt(j));  //将这个按钮添加到这个路径中  
                //我们执行递归的时候要进行这个初始位置的判断  
                backTracking(button+1,s);  
  
                //进行回溯  
                path.remove(path.size()-1);  //移除最后一个元素  
            }  
        }  
    }  
  
}
```

## 遇到的问题

1. 我这个是利用集合做的,但是原题目要求的是字符,因此要将这个转化为字符集合
2. 越界问题

```java
        //没有这个会越界的  
        if(button==digit.length){  
            return;  
        }  
```


3. ![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305201524103.png)

通过调试代码发现这个执行了,所以添加了一个元素,因此多了一个双引号
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305201527594.png)

解决办法,我们通过加入一个判断语句就可以了.

4. ![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305201532925.png)
这个一看就看出来了,是我循环的次数有问题,发现我循环的次数是固定的3....服了,真不认真,,,
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305201533711.png)


## 最终代码

```java
class Solution {
    ArrayList<Character> path = new ArrayList<>();
    List<String> list = new ArrayList<>();
    ArrayList<String> ch = new ArrayList<>();
    public List<String> letterCombinations(String digits) {
        ch.add("");
        ch.add("");
        ch.add("abc");
        ch.add("def");
        ch.add("ghi");
        ch.add("jkl");
        ch.add("mno");
        ch.add("pqrs");
        ch.add("tuv");
        ch.add("wxyz");

        backTracking(0,digits);
        return list;

    }
    public void backTracking(int button,String s){
        if(path.size()==s.length()&&s.length()!=0){
            StringBuilder sb = new StringBuilder();
            for (Character c : path) {
                sb.append(c);
            }
            list.add(sb.toString());
        }
        //没有这个会卡顿的
        if(button==s.length()){
            return;
        }
        //两轮循环
        for(int i=s.charAt(button)-48;button<s.length();button++){
            for(int j=0;j<ch.get(i).length();j++){
                path.add(ch.get(i).charAt(j));  //将这个按钮添加到这个路径中
                //我们执行递归的时候要进行这个初始位置的判断
                backTracking(button+1,s);

                //进行回溯
                path.remove(path.size()-1);  //移除最后一个元素
            }
        }
    }
}
```