---
{"dg-publish":true,"permalink":"/05leecode//77/","dgPassFrontmatter":true}
---

## 链接

[leecode77题](https://leetcode.cn/problems/combinations/)

## 题目
给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

## 示例
```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```
输入：n = 1, k = 1
输出：[[1]]
```

## 分析
### 为什么这个不能用暴力循环破解

![img](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305161950096.jpg)

### 树形结构
![img](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305161951928.png)

### 递归分析
![img](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305161953713.png)

### 伪代码

![O514GA4}OQBLS3T](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202305161954187.png)

## 代码
### 总结
这个题是我没有理解好题目,因为我自己喜欢做题的时候画上那么一分钟的时间的放到IDEA里面,方便自己之后进行代码的调试,正常来说这个代码应该是返回这个集合呢,但是我因为听完卡尔学长的课之后就直接开始编了,由于他讲课的时候说的是结果存放的是在二维数组,路径存放的是一维数组.我于是也是按照这个一维数组和二维数组进行做的.
当然在做的时候遇到了一些问题,比如说怎么判断这个路径的长度,如果是集合的话,由于集合的长度是可以变化的,所以我们可以直接用.length进行判断,但是这个是数组的话,我想的方法是统计这个数组中非零的个数,但是由于这个数组在经过递归后,数组长度会发生变化,所以我们要多次统计这个length
```java
int num = (int) IntStream.of(path).filter(i -> i != 0).count(); // 不为 0 的元素个数  
```
还有一点就是将一维数组往二维数组中进行传递值的时候,刚开始的犯了这个特别简单的错误,我是地址传递,不是值传递.
```java
result[count++]=path;       //存放这个路径  
```
这种方法到最后 输出的全部是0
于是进行了修改
```java
for(int i=0;i<k;i++){  
	result[count][i]=path[i];  
}  
```
最后也是实现了这个代码

```java
package backtracking;  
  
import java.util.Arrays;  
import java.util.Scanner;  
import java.util.stream.IntStream;  
  
public class Combine {  
    static int count = 0;  
  
    public static void main(String[] args) {  
        int n;  
        int k;  
        Scanner input = new Scanner(System.in);  
        System.out.println("输入n,1 <= n <= 20");  
        n=input.nextInt();  
        System.out.println("输入k,1 <= k <= n");  
        k=input.nextInt();  
        int[] path = new int[k];  
        int[][] result = new int[n*n][k];   //构建一个最大的数组，这里有问题啊，不太清楚  
        //这个是用二维数组做的，但很可以这个二维数组不是要求的返回值，好久没做题，题目看的有问题，我说怎么感觉二维数组这么难操作，用集合就正常多了  
        backTracking(n,k,1,path,result);   //从1开始  
        for(int i=0;i<count;i++){  
            System.out.println(Arrays.toString(result[i]));  
        }  
    }  
    public static void backTracking(int n, int k, int startIndex,int[] path,int[][] result){  
        //终止条件  
        //这个path本身的不为0的长度我们要自己去找出来  
        int num = (int) IntStream.of(path).filter(i -> i != 0).count(); // 不为 0 的元素个数  
        if(num==k){  
            //到达了叶子节点，然后我收集结果  
            //这个是值传递  
            //result[count++]=path;       //存放这个路径  
            for(int i=0;i<k;i++){  
                result[count][i]=path[i];  
            }  
            count++;  
            return;  
        }  
        //单层搜索的逻辑  
        for (int i= startIndex;i<=n;i++){  
            //ba这个i放到这个path中  
            num = (int) IntStream.of(path).filter(j -> j != 0).count(); // 不为 0 的元素个数  
            path[num]=i;  
            backTracking(n,k,i+1,path,result);  
            //我们要进行回溯  
            //要弹出这个path中的最后一个元素  
            num = (int) IntStream.of(path).filter(j -> j != 0).count(); // 不为 0 的元素个数  
            path[num-1]=0;  
        }  
    }  
}
```

### 集合方法的代码

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        combineHelper(n, k, 1);
        return result;
    }

    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++){
            path.add(i);
            combineHelper(n, k, i + 1);
            path.removeLast();
        }
    }
}
```