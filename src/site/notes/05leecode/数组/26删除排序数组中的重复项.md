---
{"dg-publish":true,"permalink":"/05leecode//26/","dgPassFrontmatter":true}
---

# 双指针法的介绍 

**下面内容转载自代码随想录**
点击进入[代码随想录](https://programmercarl.com/)
双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

很多同学这道题目做的很懵，就是不理解 快慢指针究竟都是什么含义，所以一定要明确含义，后面的思路就更容易理解了。


删除过程如下：
![image.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202307091030933.png)




# 代码版本

## 第一次错误
//这种解法,错误在这个只考虑到有不等存在的情况,如果所有的元素都相等的话,这里会出现错误
//暴力方法很多时候的确能够解决问题,但是暴力方法我用的时候总是感觉只把这个逻辑写了出来,并没有考虑到所有的情况

```java
    public static int removeDuplicates(int[] nums) {
        int count=0;
        int length = nums.length;
        if(length==1){
            return 1;
        }
        for (int i = 0; i < length-1; i++) {
            if(nums[i]!=nums[i+1]){
                nums[count]=nums[i];
                count++;
            }
        }
        if(nums[length-1]!=nums[length-2]){
            nums[count]=nums[length-1];
            count++;
        }
        return count;
    }
}

```

## 第二次成功

相比第一次改变了 循环条件,使其能够适用于所有的情况,不需要在考虑到数组的越界等问题.相比这第一次改进了好多,但是还是要考虑这个特殊情况1的时候,这个代码的通用性仍然不是太强

```java
package 数组;

import java.util.Scanner;

public class 删除排序数组中的重复项26 {
    public static void main(String[] args) {
        int n;
        Scanner input = new Scanner(System.in);
        System.out.println("请输入数组的长度");
        n=input.nextInt();
        int[] num = new int[n];
        System.out.println("按照递增的顺序输入数组的元素");
        for (int i = 0; i < num.length; i++) {
            num[i]= input.nextInt();
        }
        int index=removeDuplicates(num);
        System.out.println(index);
        for (int i = 0; i < index; i++) {
            System.out.println(num[i]);
        }
    }
    public static int removeDuplicates(int[] nums) {
        int count=0;
        int length = nums.length;
        if(length==1){
            return 1;
        }
        int index =nums[0];  //修改代码
        nums[count]=nums[0];
        count++;
        for (int i = 1; i < length; i++) {
            if(nums[i]!=index){
                nums[count]=nums[i];
                index=nums[i];
                count++;
            }
        }
        return count;
    }
}
```

## 优化代码

我在想能不能够把这个特殊情况给考虑进入循环,而不是让他在这里占据几行代码

```java
    public static int removeDuplicates(int[] nums) {
        int count=0;
        int length = nums.length;
        int index = 100000;  //根据取值范围赋值一个取不到的值
        for (int i = 0; i < length; i++) {
            if(nums[i]!=index){
                nums[count]=nums[i];
                index=nums[i];
                count++;
            }
        }
        return count;
    }
```