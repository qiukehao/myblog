---
{"dg-publish":true,"permalink":"/05leecode//35/","dgPassFrontmatter":true}
---

# 代码分析
## 难点
1. 相比704的二分搜索算法这一个多了一个寻找插入位置的选项  
2. 区别在于704二分搜索算法我们查找失败返回的是-1,这个查找失败我们要返回这个下标元素,所以怎么利用我们已经定义的变量来确定这个下标是关键

## 按照这个红色圆圈标注的顺序进行分析代码

![](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202307051603316.png)


# 源代码

```java
package 数组;

import java.util.Scanner;

public class 搜索插入位置35 {
    public static void main(String[] args) {
        int n;
        Scanner input = new Scanner(System.in);
        System.out.println("请输入数组的长度");
        n=input.nextInt();
        int[] num = new int[n];
        System.out.println("按照递增的顺序输入数组的元素");
        for (int i = 0; i < num.length; i++) {
            num[i]= input.nextInt();
        }
        System.out.println("请输入你要查找的目标值");
        int target = input.nextInt();
        System.out.println(searchInsert(num, target));
    }
    public static int searchInsert(int[] nums, int target) {
        //相比704的二分搜索算法这一个多了一个寻找插入位置的选项
        //区别在于704二分搜索算法我们查找失败返回的是-1,这个查找失败我们要返回这个下标元素,所以怎么利用我们已经定义的变量来确定这个下标是关键
        int length = nums.length;
        int left =0,right =length-1;
        int m=0;
        while(left<=right){
            m=(left+right)/2;
            if(nums[m]<target){
                left=m+1;
            }else if(nums[m]>target){
                right=m-1;
            }else return m;
        }
        //return m+1;//第一次尝试的失败代码
        return right+1;
        return left;
    }
}

```