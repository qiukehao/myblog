---
{"dg-publish":true,"permalink":"/05leecode//904/","dgPassFrontmatter":true}
---


# 思路讲解和分析

![ee486f876cdccb63433135c6ec6c5528_720.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202307101640074.png)

![98b9598a519f4d89109969ab33adbee2_720.png](https://qkh-markdown-1316031240.cos.ap-nanjing.myqcloud.com/obsidian/202307101640367.png)


# 代码分析
## 通过代码(未优化)

参考这个错误分析对这个代码进行分析,并抽时间进行优化

```java
    public static int totalFruit(int[] fruits) {
        int fast = 0,low=0;
        int length=0;
        int type1=fruits[fast];
        int type2=fruits[low];
        int mark=0;  //引入一个标记位
        int index=0;  //确定更新位置
        for(fast=0;fast<fruits.length;fast++){
            if(fruits[fast]==type1||fruits[fast]==type2){
                //这个fruit.length的长度是不是可以利用牺牲空间换时间来进行调整
//                if(fast<fruits.length-1&&fruits[fast]!=fruits[fast+1]){
//                    index=fast+1;   //确定low的更新位置
//                }
                length=Math.max(length,fast-low+1); //更新数组长度
            }
            //什么进行更新数据呢
            else if(fruits[fast]!=type1&&fruits[fast]!=type2){
                //当读取到的元素不等于第一个元素,也不等于第二个元素的时候要进行更新low
                //这个更新当对type第一次复制的时候low是不进行改变的,改变的是第二次赋值的时候,所以说我们在这里再加入一个判断语句
                //这个的这个判断语句并不能解决所有的情况,因此我们不能这样做
                if(mark==0){
                    type2=fruits[fast];
                    mark=1;
                }else {
                    type2=fruits[fast];
                    //low=index;//要求low,我直接进行一个循环,就不用这个标记位了
                    index=fast-1;
                    while(index>=1&&fruits[index]==fruits[index-1]){
                        index--;
                        low=index;
                    }
                    if(index==fast-1){
                        low=index;
                    }
                    type1=fruits[low];
                }
                length=Math.max(length,fast-low+1); //更新数组长度
            }
        }
        return length;
    }
}

```


## 优化后完整代码

```java
package 数组;

import com.sun.prism.shader.DrawEllipse_LinearGradient_REFLECT_AlphaTest_Loader;

import java.util.Scanner;

public class 水果成篮904 {
    public static void main(String[] args) {
        int n;
        Scanner input = new Scanner(System.in);
        System.out.println("请输入数组的长度");
        n=input.nextInt();
        int[] num = new int[n];
        System.out.println("输入数组的元素");
        for (int i = 0; i < num.length; i++) {
            num[i]= input.nextInt();
        }
        System.out.println(totalFruit(num));
    }
    public static int totalFruit(int[] fruits) {
        int fast = 0,low=0;int length=0;
        int type1=fruits[fast];int type2=fruits[low];
        int index=0;  //确定更新位置
        for(fast=0;fast<fruits.length;fast++){
            if(fruits[fast]!=type1&&fruits[fast]!=type2){
                //优化代码这个mark能不能消去.想了半天还是没有想到这个index这个有没有别的优化代码,感觉这样就差不多了
                if(index==0){
                    type2=fruits[fast];
                    index=-1;
                }else {
                    type2=fruits[fast];
                    //优化代码这个后面的一个循环一个判读能不能对其进行缩减
                    low = fast - 1;
                    while (low >= 1 && fruits[low] == fruits[low - 1]) {
                        low -= 1;
                    }
                    type1 = fruits[low];
                }
            }
            length=Math.max(length,fast-low+1); //更新数组长度
        }
        return length;
    }
}

```