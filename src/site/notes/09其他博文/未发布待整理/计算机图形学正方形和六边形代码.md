---
{"dg-publish":true,"permalink":"/09///","dgPassFrontmatter":true}
---


代码的头文件
```c
#define GLEW_STATIC  //声明静态库, 而不是动态库
#include \<iostream>		
#include <GL/glew.h>	//引入这个 glew 库
#include <GLFW/glfw3.h> //引入这个 glfw 库
```
着色器代码
对于这两个着色器来说这个 vertexShaderSource 和 fragmentShaderSource 是这个指针变量，分别指向两个着色器指针变量
顶点着色器
```cpp
const GLchar* vertexShaderSource = " #version 330 core\n"   //声明这个使用的 GLSL 的代码版本
"layout (location = 0) in vec 3 position;\n"  //定义一个输入变量 position, 它位于属性位置 0, 这个变量是一个有三浮点数的向量
"void main ()\n"  //定义这个主函数, 这个是顶点着色器的入口函数
"{\n"
"gl_Position = vec 4 (position, 1.0 f);\n"   //这个 glPosition 是一个内置的变量,
"}";
```
难点
`Layout (location = 0) in vec 3 position;\n`
在 OpenGL 中，顶点数据通常是通过顶点缓冲对象 (VBO)来传递给渲染管线的。顶点着色器需要从 VBO 中读取顶点数据并进行处理。因此，我们需要定义一个输入变量来表示从 VBO 中读取到的数据，并指定这个变量对应 VBO 中的数据类型和位置。
`layout (location = 0) in vec 3 position;`
这行代码中的 `location` 属性就是用来指定顶点数据在 VBO 中的位置。具体来说，`location` 属性是一个装饰符（decorator），可以与变量一起使用，用于指定变量在顶点缓冲中的位置信息。
在上述代码中，`location = 0` 指定了变量 `position` 对应于顶点缓冲中的第 0 个位置，也就是它表示 VBO 中存储的顶点坐标数据。这个位置信息通常是通过绑定 VBO、设置数据指针等操作得到的。
另外，需要注意的是，在 OpenGL 4.3 及以上版本中，`layout (location = x)` 是必须要使用的。在低版本中，可能会采用一些其他的方式来指定顶点数据的位置信息，比如使用顶点属性数组索引或者顶点着色器内置的输入变量名字。但是这些方式都不如 `layout (location = x)` 来得直观和灵活。
`Gl_Position = vec 4 (position, 1.0 f);\n`
`Gl_Position ` 是一个内置的输出变量，并且是顶点着色器中的特殊变量。
在 OpenGL 中，顶点着色器使用 gl_Position 变量来指定每个顶点的最终裁剪空间坐标。顶点着色器将对输入的顶点坐标进行处理，并将结果赋值给 gl_Position 变量，以便后续的图形管线阶段（如光栅化和片段着色器）能够使用这个坐标来进行裁剪、投影和其他操作。
在你提供的代码中，`gl_Position = vec 4 (position, 1.0 f) ` 将顶点坐标 `position` 转换为齐次坐标，并将结果赋值给 `gl_Position` 变量。在这里，`vec 4 (position, 1.0 f) ` 构造了一个四维向量，其中 ` position` 是输入的顶点坐标，而 1.0 f 则是权重（weight）或者齐次坐标的第四个分量。
片段着色器
```cpp
const GLchar* fragmentShaderSource = " #version 330 core\n"  //和顶点着色器一样指定这个该着色器所使用的 OpenGL 的版本的核心模式
"out vec 4 FragColor;\n"  // 定义一个这个思维的输出变量和这个顶点着色器变量不同的是这个 FragColor 变量是一个需要我们自己定义的输出变量, 这个 gl_position 变量是一个内置的输出变量.
"void main ()\n"
"{\n"
"FragColor = vec 4 (1.0 f, 0.5 f, 0.2 f, 0.0 f);\n"  //四维输出变量具体为红色（1.0 f）、绿色（0.5 f）、蓝色（0.2 f）和透明度（0.0 f）。其中红绿蓝为三原色. 设置半透明度，可以将最后一个参数 0.0 f 改为一个介于 0.0 和 1.0 之间的值。该值表示颜色的 alpha 通道，控制透明度的程度。接近 1.0 的值表示更不透明，接近 0.0 的值表示更透明
"}";
```
创建着色器程序
下面的这个函数顾名思义就是一个着色器的构造函数, 通过这个函数我们来构造着色器, 上面那两个只是两个着色器指针而已
```cpp
/定义一个函数名为 CreateShaderProgram 着色器创建函数
//`GLuint`是 OpenGL 中定义的无符号整数类型。它通常用于表示 OpenGL 对象的标识符，比如着色器、纹理、缓冲区等。在代码中，`GLuint`变量被用来存储着色器和着色器程序的标识符。
Static void CreateShaderProgram (GLuint& shaderProgram) {
    /*
    * glCreateShader (GL_VERTEX_SHADER)是 OpenGL 函数，用于创建一个顶点着色器对象，并返回这个对象的 ID,
    * 其中参数 GL_VERTEX_SHADER 的作用是指定了要创建的对象类型为顶点着色器
    * 通过调用 glCreateShader (GL_VERTEX_SHADER)函数，可以创建一个顶点着色器对象，并得到一个唯一的标识符（即 GLuint 类型的值），用于后续操作，比如将源代码关联到着色器对象、编译着色器等。
    */
    GLuint vertexShader = glCreateShader (GL_VERTEX_SHADER);
    
    /**
    *这个 vertexShader 就是这个着色器对象, 这个 1 指定这个源代码字符串数组的数量, 由于我们只有一个源代码字符串, 所以我们这里就填这个 1, 因为我们上面只定义了一个顶点着色器.
    *这个&vertexShaderSource 是用来指定这个顶点着色器的源代码的指针
    *NULL：指定用于指示源代码字符串长度的参数。如果不需要传入源代码字符串的长度，则可以将其设置为 NULL
    *这行代码的作用就是实现了上一步中的讲源代码关联到这个着色器对象中 
    */
    GlShaderSource (vertexShader, 1, &vertexShaderSource, NULL);  

    /**
    *系统编译这个丢你给点着色器对象
    */
    GlCompileShader (vertexShader);
    
    /**
    *GLint 是 OpenGL 中定义的一个整数类型，通常用于表示 OpenGL 函数的返回值、状态或属性。
    *GLint 是 OpenGL 的数据类型之一，它可以用来表示整数值，包括正整数、负整数和零。它在 OpenGL 函数中广泛使用，作为参数传递给函数或用于存储函数的返回结果。
    *在 C/C++语言中，GLint 实际上是一个预定义的类型别名（typedef），它被定义为一个有符号整数类型。具体的实现可能根据不同平台和编译器而有所不同，但通常它被定义为一个 32 位的有符号整数。
    *因此，在使用 OpenGL 函数时，你可以声明一个 GLint 类型的变量，并将其用于存储函数的返回值或其他需要使用整数的地方。例如，在下面的代码中，GLint success 就是用来存储编译和链接状态的整数变量。
    */
    GLint success;
    
    /**
    *这个代码的作用是获取这个顶点编译器的状态, 并将其的状态的结果存放到这个 success 变量中去.
    *GL_COMPILE_STATUS：指定要查询的属性名称，即编译状态。GL_COMPILE_STATUS 是 OpenGL 定义的一个常量，用于表示编译是否成功。它将用作后续查询的属性参数之一
    */
    GlGetShaderiv (vertexShader, GL_COMPILE_STATUS, &success);
    
    /**
    *如果顶点着色器编译失败, 则输出这个错误日志信息并推出程序
    *GLchar infolog[1024];：定义一个长度为 1024 的字符数组 infolog，用于存储错误信息。
    *glGetShaderInfoLog (vertexShader, 1024, NULL, infolog);：调用 glGetShaderInfoLog 函数，获取与顶点着色器对象关联的信息日志。第一个参数是顶点着色器对象标识符，第二个参数是 infolog 字符数组的大小，第三个参数是一个指向整数的指针，用于存储返回的实际字符数（这里使用 NULL 表示不关心实际字符数），第四个参数是用于存储信息日志的字符数组。
    *std:: cout << "ERROR::SHADER:: VETEX:: COMPILATION_FAILED\n" << infolog << std:: endl;：将错误信息和自定义的错误提示输出到标准输出流。Std:: cout 代表标准输出流，<<用于连接输出内容。错误提示字符串"ERROR::SHADER:: VETEX:: COMPILATION_FAILED"用于表明出错的位置，infolog 包含了具体的错误信息。
    *exit (-1);：调用 exit 函数强制退出程序，并返回状态码-1，表示异常退出
    */
    If (! Success) {
        GLchar infolog[1024];
        GlGetShaderInfoLog (vertexShader, 1024, NULL, infolog);
        Std:: cout << "ERROR::SHADER:: VETEX:: COMPILATION_FAILED\n" << infolog << std:: endl;
        Exit (-1);
    }
    
    /**
    *和前面的顶点着色器对象类似, 这里是定义一个这个片段着色器对象
    *这个 GL_FRAGMENT_SHADER 是用来指定创建的变量类型
    */
    GLuint fragmentShader = glCreateShader (GL_FRAGMENT_SHADER);
    
    /**
    *和上面的顶点着色器一样, 这里是将这个片段着色器对象连接到这个着色器指针指向的源代码片段
    */
    GlShaderSource (fragmentShader, 1, &fragmentShaderSource, NULL);
    
    /**
    *编译片段着色器
    */
    GlCompileShader (fragmentShader);
    
    /**
    *获取这个片段着色器的编译状态
    */
    GlGetShaderiv (fragmentShader, GL_COMPILE_STATUS, &success);
    
    /**
    *如果片段编译器编译失败, 则输出这个片段着色器的错误日志, 并退出程序
    */
    If (! Success) {
        GLchar infolog[1024];
        GlGetShaderInfoLog (fragmentShader, 1024, NULL, infolog);
        Std:: cout << "ERROR::SHADER:: VETEX:: COMPILATION_FAILED\n" << infolog << std:: endl;
        Exit (-1);
    }
    
    /**
    *讲顶点着色器附加到着色器程序, 将片段着色器附加到这个着色器程序
    *这个 shaderProgram 是我们传递到这个创建着色器对象中的参数
    */
    GlAttachShader (shaderProgram, vertexShader);
    GlAttachShader (shaderProgram, fragmentShader);
    
    /**
    *链接这个着色器程序
    */
    GlLinkProgram (shaderProgram);
    
    /**
    *获取这个着色器程序的链接状态需要注意的是这个获取的是这个链接状态, 上面那两个获取的是编译状态
    */
    GlGetProgramiv (shaderProgram, GL_LINK_STATUS, &success);
    
    /**
    *输出这个着色器程序的错误日志, 并退出程序
    */
    If (! Success) {
        GLchar infolog[1024];
        GlGetProgramInfoLog (shaderProgram, 1024, NULL, infolog);
        Std:: cout << "ERROR::SHADER:: PROGRAM:: LINK_FAILED\n" << infolog << std:: endl;
        Exit (-1);
    }
    
    /**
    *验证这个着色器程序, 这个是和前两个不太一样的点, 前面的顶点着色器对象, 和这个片段着色器对象, 都是没有这个验证程序的.
    */
    GlValidateProgram (shaderProgram);
    
    /**
    *判断这个着色器程序的验证状态
    */
    GlGetProgramiv (shaderProgram, GL_VALIDATE_STATUS, &success);
    If (! Success) {
        GLchar infolog[1024];
        GlGetProgramInfoLog (shaderProgram, 1024, NULL, infolog);
        Std:: cout << "ERROR::SHADER:: PROGRAM:: VALIDATE_FAILED\n" << infolog << std:: endl;
        Exit (-1);
    }
    
    /**
    *删除这个顶点着色器对象
    *删除这个片段着色器对象
    */
    GlDeleteShader (vertexShader);
    GlDeleteShader (fragmentShader);
}



```
创建两个对象, 分别是顶点数组对象和顶点缓冲对象标识符
   ```cpp
 /**
    *GLuint VAO;：VAO 是一个无符号整数类型的变量，用于表示顶点数组对象（Vertex Array Object）的标识符。顶点数组对象是 OpenGL 中一种用于管理顶点数据、顶点属性配置和绘制状态的对象。通过将顶点数据和配置信息绑定到顶点数组对象上，可以方便地进行顶点数据的设置和切换。在这里，VAO 变量将被用作顶点数组对象的标识符。
    *GLuint VBO;：VBO 也是一个无符号整数类型的变量，用于表示顶点缓冲对象（Vertex Buffer Object）的标识符。顶点缓冲对象是 OpenGL 中一种用于存储和管理顶点数据的缓冲区对象。它可以用来存储顶点坐标、顶点颜色、法向量等顶点属性数据。在渲染过程中，可以将顶点数据从 CPU 传输到顶点缓冲对象中，并通过绑定顶点缓冲对象来指定要使用的顶点数据。在这里，VBO 变量将被用作顶点缓冲对象的标识符。
    */
    GLuint VAO, VBO;
```
创建一个包含三个顶点的顶点缓冲区, 也就是我们呈现出这个结果的代码
```cpp
Static void CreatedVertexBuffer () {
    /**
    *定义了一个包含三个顶点的浮点数组 vertices。每个顶点由三个浮点数（x、y、z 坐标）组成。如果我想定义一个正方形的话就定义四个点.
    */
    GLfloat vertices[] = { -0.5 f,-0.5 f, 0.0 f,
                            0.0 f, 0.5 f, 0.0 f,
                            0.5 f,-0.5 f, 0.0 f };
                            
    /**
    *这个 Gen 是生成的意思
    *第一个参数：指定要生成的顶点数组对象（VAO）的数量。在这个例子中，我们只需要生成一个顶点数组对象，所以这个参数的值为 1。
    *第二个参数：指向保存生成的顶点数组对象标识符的变量的指针。顶点数组对象标识符是一个无符号整数（GLuint 类型），用于标识顶点数组对象。生成的顶点数组对象标识符会被存储在这个指针所指向的变量中。在这个例子中，我们使用了名为 VAO 的变量来保存生成的顶点数组对象标识符的值，所以传入的是&VAO。
    */
    GlGenVertexArrays (1, &VAO);
    
    /**
    *和上面生成顶点数组对象类似, 这个是生成一个顶点缓冲对象, 并将这个标识符保存到这个名为 VBO 的变量中.
    */
    GlGenBuffers (1, &VBO);
    
    /**
    *这个 Bind 是绑定的意思, 用来绑定这个顶点数组对象, 并将其设置为当前 OpenGL 上下文中当前的顶点数组对象.
    */
    GlBindVertexArray (VAO);
    
    /**
    *将顶点缓冲对象（VBO）绑定到 GL_ARRAY_BUFFER 目标上，表示将要对 GL_ARRAY_BUFFER 目标进行操作。
    */
    GlBindBuffer (GL_ARRAY_BUFFER, VBO);
    
    /**
    *分配并初始化当前绑定的顶点缓冲区对象的数据存储。这里将顶点数据（vertices 数组, 我们定义的三个顶点数组）复制到当前绑定的顶点缓冲区对象（VBO）中。Sizeof (vertices)得到 vertices 数组的字节大小。
    */
    GlBufferData (GL_ARRAY_BUFFER, sizeof (vertices), vertices, GL_STATIC_DRAW);
    
    /**
    *指定顶点属性数组的布局。这里设置了顶点属性索引为 0 的属性指针，每个顶点有 3 个分量，并且每个分量的类型是浮点型。
    *第一个参数：指定要配置的顶点属性的索引。顶点属性的索引与着色器程序中对应的输入变量的位置（location）相对应。在这里，使用属性索引 0 来配置顶点的位置信息。
    *第二个参数：指定每个顶点属性的组件数量。在这里，每个顶点属性由 3 个分量（x、y、z 坐标）组成。
    *第三个参数：指定顶点属性的数据类型。在这里，顶点属性的数据类型是浮点型，所以使用 GL_FLOAT。
    *第四个参数：指定是否对顶点属性中的每个分量进行归一化处理。如果为 GL_TRUE，则会将无符号整数类型的数据归一化到[0,1]之间，有符号整数类型的数据归一化到[-1,1]之间；如果为 GL_FALSE，则不进行归一化处理。在这里，我们没有进行归一化处理，所以使用 GL_FALSE。
    *第五个参数：指定顶点属性数据在数组中的偏移量。在这里，我们使用了连续存储的顶点数据，所以偏移量为每个顶点属性的大小。对于每个顶点属性的大小，我们使用了 3 * sizeof (GLfloat)，其中 sizeof (GLfloat)表示一个浮点型变量的字节大小。
    *第六个参数：指定顶点数组中顶点属性数据的首地址。在这里，我们将顶点属性数据存储在了顶点缓冲区对象中，所以传入的是偏移量为 0 的地址 (GLvoid*) 0，表示从顶点缓冲区对象的起始位置开始。
    */
    GlVertexAttribPointer (0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof (GLfloat), (GLvoid*) 0);
    /**
    *启用顶点属性数组，使其对渲染管线可见
    */
    GlEnableVertexAttribArray (0);
}
```
设置视点函数
```cpp
Static void SetViewport (GLFWwindow* window) {
    Int screenWidth, screenHeight;
    
    /**
    *这里使用 glfwGetFramebufferSize 函数来获取当前窗口的帧缓冲区的宽度和高度，存储在 screenWidth 和 screenHeight 变量中。
    */
    GlfwGetFramebufferSize (window, &screenWidth, &screenHeight);
    
    /**
    *通过调用 glViewport 函数，将视口的左下角设置为 (0,0)，将视口的宽度和高度设置为帧缓冲区的宽度和高度。这样一来，OpenGL 的渲染输出将会映射到整个窗口的帧缓冲区
    */
    GlViewport (0, 0, screenWidth, screenHeight);
}
```

渲染函数
```cpp
Static void RenderScreen (GLFWwindow* window) {

    //屏幕的背景色, 这里的颜色是浅蓝色。
    GlClearColor (0.2 f, 0.3 f, 0.3 f, 1.0 f);
    
    //通过调用 glClear 函数，清空当前帧缓冲区的颜色缓冲区，使其填充为之前设置的清空颜色
    GlClear (GL_COLOR_BUFFER_BIT);
    
    //通过调用 glBindVertexArray 函数，绑定之前生成的顶点数组对象 VAO。这样一来，后续的绘制命令将会应用于该顶点数组对象。
    GlBindVertexArray (VAO);
    
    //通过调用 glDrawArrays 函数，使用当前绑定的顶点数组对象 VAO，绘制指定类型的图元。在这里，绘制的是三角形，顶点数据从顶点数组对象的起始位置开始，绘制 3 个顶点。
    GlDrawArrays (GL_TRIANGLES, 0,3);
    //glBindVertexArray (0);。通过调用 glBindVertexArray 函数，将当前绑定的顶点数组对象置为 0，表示解绑操作。
    GlBindVertexArray (0);
    //通过调用 glfwSwapBuffers 函数，交换指定窗口的前后帧缓冲区，实现渲染结果在窗口中显示出来。
    GlfwSwapBuffers (window);
}`
```

最终代码
```cpp
#define GLEW_STATIC
#include <iostream>
#include <GL/glew.h>
#include <GLFW/glfw3.h>//配置第三方库
/*
* " #version 330 core\n"：GLSL 所用的版本号，当前代码使用的是 3.3 版本，核心（core）模式。
* "layout (location = 0) in vec 3 position;\n"：定义了一个输入变量 position，它的位置是 0，即 GPU 中的顶点属性数组中的第一个位置。这个变量是一个三维向量，表示输入的顶点坐标
* "void main ()\n"：GLSL 程序中的主函数，类似于 C 语言的 main 函数
* "gl_Position = vec 4 (position, 1.0 f);\n"：将输入变量 position 赋值给内置变量 gl_Position，它代表的是经过模型、视图和投影矩阵变换后的顶点坐标，这里将它转换为齐次坐标形式，并将其赋值给 gl_Position。由于 OpenGL 中使用的是右手坐标系，因此 z 轴是朝屏幕外的，w 坐标通常设置为 1.0 f。
*/
const GLchar* vertexShaderSource = " #version 330 core\n"
"layout (location = 0) in vec 3 position;\n"
"void main ()\n"
"{\n"
"gl_Position = vec 4 (position, 1.0 f);\n"
"}";
/*
*" #version 330 coure\n"：GLSL 所用的版本号，当前代码使用的是 3.3 版本，"coure" 可能是拼写错误，应该是 "core"。
*"out vec 4 FragColor;\n"：定义了一个输出变量 FragColor，它是一个四维向量，表示片段的颜色值。
*"void main ()\n"：GLSL 程序中的主函数，类似于 C 语言的 main 函数。
*"FragColor = vec 4 (1.0 f, 0.5 f, 0.2 f, 0.0 f);\n"：将颜色值 (1.0, 0.5, 0.2, 0.0) 赋值给输出变量 FragColor，表示将此颜色作为片段的最终颜色。
* "}"：函数主体的结束标志。
*/
const GLchar* fragmentShaderSource = " #version 330 core\n"
"out vec 4 FragColor;\n"
"void main ()\n"
"{\n"
"FragColor = vec 4 (1.0 f, 0.5 f, 0.2 f, 0.0 f);\n"
"}";

//program handle , shader handle ,compile and link program
Static void CreateShaderProgram (GLuint& shaderProgram) {
    GLuint vertexShader = glCreateShader (GL_VERTEX_SHADER);
    GlShaderSource (vertexShader, 1, &vertexShaderSource, NULL);
    GlCompileShader (vertexShader);
    GLint success;
    GlGetShaderiv (vertexShader, GL_COMPILE_STATUS, &success);
    If (! Success) {
        GLchar infolog[1024];
        GlGetShaderInfoLog (vertexShader, 1024, NULL, infolog);
        Std:: cout << "ERROR::SHADER:: VETEX:: COMPILATION_FAILED\n" << infolog << std:: endl;
        Exit (-1);
    }
    GLuint fragmentShader = glCreateShader (GL_FRAGMENT_SHADER);
    GlShaderSource (fragmentShader, 1, &fragmentShaderSource, NULL);
    GlCompileShader (fragmentShader);
    GlGetShaderiv (fragmentShader, GL_COMPILE_STATUS, &success);
    If (! Success) {
        GLchar infolog[1024];
        GlGetShaderInfoLog (fragmentShader, 1024, NULL, infolog);
        Std:: cout << "ERROR::SHADER:: VETEX:: COMPILATION_FAILED\n" << infolog << std:: endl;
        Exit (-1);
    }
    GlAttachShader (shaderProgram, vertexShader);
    GlAttachShader (shaderProgram, fragmentShader);
    GlLinkProgram (shaderProgram);
    GlGetProgramiv (shaderProgram, GL_LINK_STATUS, &success);
    If (! Success) {
        GLchar infolog[1024];
        GlGetProgramInfoLog (shaderProgram, 1024, NULL, infolog);
        Std:: cout << "ERROR::SHADER:: PROGRAM:: LINK_FAILED\n" << infolog << std:: endl;
        Exit (-1);
    }
    GlValidateProgram (shaderProgram);
    GlGetProgramiv (shaderProgram, GL_VALIDATE_STATUS, &success);
    If (! Success) {
        GLchar infolog[1024];
        GlGetProgramInfoLog (shaderProgram, 1024, NULL, infolog);
        Std:: cout << "ERROR::SHADER:: PROGRAM:: VALIDATE_FAILED\n" << infolog << std:: endl;
        Exit (-1);
    }
    GlDeleteShader (vertexShader);
    GlDeleteShader (fragmentShader);
}
//vertex specification
GLuint VAO, VBO, VAO 1, VBO 1, VAO 2, VBO 2;
Static void CreatedVertexBuffer () {
    //实现了这个正方形的水平偏移
    GLfloat vertices[] = { -0.7 f, 0.2 f, 0.0 f,
                            -0.3 f, 0.2 f, 0.0 f,
                            -0.7 f,-0.2 f, 0.0 f,
                            -0.3 f,-0.2 f, 0.0 f };

    GLfloat vertices 1[] = { 0.3 f,-0.15 f, 0.0 f,
                            0.5 f, 0.25 f, 0.0 f,
                            0.7 f,-0.15 f, 0.0 f };

    GLfloat vertices 2[] = { 0.3 f, 0.15 f, 0.0 f,
                            0.5 f,-0.25 f, 0.0 f,
                            0.7 f, 0.15 f, 0.0 f };

    GlGenVertexArrays (1, &VAO);
    GlBindVertexArray (VAO);
    GlGenBuffers (1, &VBO);
    GlBindBuffer (GL_ARRAY_BUFFER, VBO);
    GlBufferData (GL_ARRAY_BUFFER, sizeof (vertices), vertices, GL_STATIC_DRAW);
    GlVertexAttribPointer (0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof (GLfloat), (GLvoid*) 0);
    GlEnableVertexAttribArray (0);


    GlGenVertexArrays (1, &VAO 1);
    GlBindVertexArray (VAO 1);
    GlGenBuffers (1, &VBO 1);
    GlBindBuffer (GL_ARRAY_BUFFER, VBO 1);
    GlBufferData (GL_ARRAY_BUFFER, sizeof (vertices 1), vertices 1, GL_STATIC_DRAW);
    GlVertexAttribPointer (0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof (GLfloat), (GLvoid*) 0);
    GlEnableVertexAttribArray (0);

    GlGenVertexArrays (1, &VAO 2);
    GlGenBuffers (1, &VBO 2);
    GlBindVertexArray (VAO 2);
    GlBindBuffer (GL_ARRAY_BUFFER, VBO 2);
    GlBufferData (GL_ARRAY_BUFFER, sizeof (vertices 2), vertices 2, GL_STATIC_DRAW);
    GlVertexAttribPointer (0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof (GLfloat), (GLvoid*) 0);
    GlEnableVertexAttribArray (0);

    GlBindVertexArray (0); // 解除绑定
}
Static void SetViewport (GLFWwindow* window) {
    Int screenWidth, screenHeight;
    GlfwGetFramebufferSize (window, &screenWidth, &screenHeight);
    GlViewport (0, 0, screenWidth, screenHeight);
}
Static void RenderScreen (GLFWwindow* window) {
    GlClearColor (0.2 f, 0.3 f, 0.3 f, 1.0 f);
    GlClear (GL_COLOR_BUFFER_BIT);
    GlBindVertexArray (VAO);
    //创建这个正方形对象
    GlDrawArrays (GL_TRIANGLE_STRIP, 0, 4);

    GlBindVertexArray (VAO 1);
    //创建这个三角形对象
    GlDrawArrays (GL_TRIANGLES, 0, 3);

    GlBindVertexArray (VAO 2);
    //创建这个三角形对象
    GlDrawArrays (GL_TRIANGLES, 0, 3);

    GlBindVertexArray (0);
    GlfwSwapBuffers (window);
}
Int main () {
    GlfwInit (); //初始化库文件
    GlfwWindowHint (GLFW_CONTEXT_VERSION_MAJOR, 3);
    GlfwWindowHint (GLFW_CONTEXT_VERSION_MINOR, 3);
    GlfwWindowHint (GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  //声明这个 openGL 的版本名字

    GLFWwindow* window = glfwCreateWindow (800, 600, "B 21080618", NULL, NULL); //后面的两个参数好像是设置全屏.
    If (window == NULL) {
        Std:: cout << "Failed to create GLFW window" << std:: endl;
        GlfwTerminate ();
        Return -1;
    }

    GlfwMakeContextCurrent (window);//当前窗口活跃, 然后设置窗口
    If (GLEW_OK != glewInit ()) {
        Std:: cout << "Failed to init glew" << std:: endl;
        GlfwTerminate ();
        Return -1;
    }

    CreatedVertexBuffer ();
    GLuint ShaderProgram = glCreateProgram ();
    CreateShaderProgram (ShaderProgram);


    While (! GlfwWindowShouldClose (window))
    {
        SetViewport (window);
        GlfwPollEvents ();
        // 渲染其他图形或场景
        GlUseProgram (ShaderProgram);
        RenderScreen (window);
        //glClearColor (1.0 f, 1.0 f, 1.0 f, 1.0 f); // 设置清屏颜色为白色
        //glClear (GL_COLOR_BUFFER_BIT);
        //glfwSwapBuffers (window);
    }

    GlfwTerminate ();
    Return 0;
}
```


